"use strict";

// An object that encapsulates everything we need to run a 'find'
// operation, encoded in the REST API format.
var SchemaController = require('./Controllers/SchemaController');

var Parse = require('parse/node').Parse;

const triggers = require('./triggers');

const {
  continueWhile
} = require('parse/lib/node/promiseUtils');

const AlwaysSelectedKeys = ['objectId', 'createdAt', 'updatedAt', 'ACL'];

const {
  enforceRoleSecurity
} = require('./SharedRest'); // restOptions can include:
//   skip
//   limit
//   order
//   count
//   include
//   keys
//   excludeKeys
//   redirectClassNameForKey
//   readPreference
//   includeReadPreference
//   subqueryReadPreference

/**
 * Use to perform a query on a class. It will run security checks and triggers.
 * @param options
 * @param options.method {RestQuery.Method} The type of query to perform
 * @param options.config {ParseServerConfiguration} The server configuration
 * @param options.auth {Auth} The auth object for the request
 * @param options.className {string} The name of the class to query
 * @param options.restWhere {object} The where object for the query
 * @param options.restOptions {object} The options object for the query
 * @param options.clientSDK {string} The client SDK that is performing the query
 * @param options.runAfterFind {boolean} Whether to run the afterFind trigger
 * @param options.runBeforeFind {boolean} Whether to run the beforeFind trigger
 * @param options.context {object} The context object for the query
 * @returns {Promise<_UnsafeRestQuery>} A promise that is resolved with the _UnsafeRestQuery object
 */


async function RestQuery({
  method,
  config,
  auth,
  className,
  restWhere = {},
  restOptions = {},
  clientSDK,
  runAfterFind = true,
  runBeforeFind = true,
  context
}) {
  if (![RestQuery.Method.find, RestQuery.Method.get].includes(method)) {
    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'bad query type');
  }

  enforceRoleSecurity(method, className, auth);
  const result = runBeforeFind ? await triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth, context, method === RestQuery.Method.get) : Promise.resolve({
    restWhere,
    restOptions
  });
  return new _UnsafeRestQuery(config, auth, className, result.restWhere || restWhere, result.restOptions || restOptions, clientSDK, runAfterFind, context);
}

RestQuery.Method = Object.freeze({
  get: 'get',
  find: 'find'
});
/**
 * _UnsafeRestQuery is meant for specific internal usage only. When you need to skip security checks or some triggers.
 * Don't use it if you don't know what you are doing.
 * @param config
 * @param auth
 * @param className
 * @param restWhere
 * @param restOptions
 * @param clientSDK
 * @param runAfterFind
 * @param context
 */

function _UnsafeRestQuery(config, auth, className, restWhere = {}, restOptions = {}, clientSDK, runAfterFind = true, context) {
  this.config = config;
  this.auth = auth;
  this.className = className;
  this.restWhere = restWhere;
  this.restOptions = restOptions;
  this.clientSDK = clientSDK;
  this.runAfterFind = runAfterFind;
  this.response = null;
  this.findOptions = {};
  this.context = context || {};

  if (!this.auth.isMaster) {
    if (this.className == '_Session') {
      if (!this.auth.user) {
        throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
      }

      this.restWhere = {
        $and: [this.restWhere, {
          user: {
            __type: 'Pointer',
            className: '_User',
            objectId: this.auth.user.id
          }
        }]
      };
    }
  }

  this.doCount = false;
  this.includeAll = false; // The format for this.include is not the same as the format for the
  // include option - it's the paths we should include, in order,
  // stored as arrays, taking into account that we need to include foo
  // before including foo.bar. Also it should dedupe.
  // For example, passing an arg of include=foo.bar,foo.baz could lead to
  // this.include = [['foo'], ['foo', 'baz'], ['foo', 'bar']]

  this.include = [];
  let keysForInclude = ''; // If we have keys, we probably want to force some includes (n-1 level)
  // See issue: https://github.com/parse-community/parse-server/issues/3185

  if (Object.prototype.hasOwnProperty.call(restOptions, 'keys')) {
    keysForInclude = restOptions.keys;
  } // If we have keys, we probably want to force some includes (n-1 level)
  // in order to exclude specific keys.


  if (Object.prototype.hasOwnProperty.call(restOptions, 'excludeKeys')) {
    keysForInclude += ',' + restOptions.excludeKeys;
  }

  if (keysForInclude.length > 0) {
    keysForInclude = keysForInclude.split(',').filter(key => {
      // At least 2 components
      return key.split('.').length > 1;
    }).map(key => {
      // Slice the last component (a.b.c -> a.b)
      // Otherwise we'll include one level too much.
      return key.slice(0, key.lastIndexOf('.'));
    }).join(','); // Concat the possibly present include string with the one from the keys
    // Dedup / sorting is handle in 'include' case.

    if (keysForInclude.length > 0) {
      if (!restOptions.include || restOptions.include.length == 0) {
        restOptions.include = keysForInclude;
      } else {
        restOptions.include += ',' + keysForInclude;
      }
    }
  }

  for (var option in restOptions) {
    switch (option) {
      case 'keys':
        {
          const keys = restOptions.keys.split(',').filter(key => key.length > 0).concat(AlwaysSelectedKeys);
          this.keys = Array.from(new Set(keys));
          break;
        }

      case 'excludeKeys':
        {
          const exclude = restOptions.excludeKeys.split(',').filter(k => AlwaysSelectedKeys.indexOf(k) < 0);
          this.excludeKeys = Array.from(new Set(exclude));
          break;
        }

      case 'count':
        this.doCount = true;
        break;

      case 'includeAll':
        this.includeAll = true;
        break;

      case 'explain':
      case 'hint':
      case 'distinct':
      case 'pipeline':
      case 'skip':
      case 'limit':
      case 'readPreference':
        this.findOptions[option] = restOptions[option];
        break;

      case 'order':
        var fields = restOptions.order.split(',');
        this.findOptions.sort = fields.reduce((sortMap, field) => {
          field = field.trim();

          if (field === '$score' || field === '-$score') {
            sortMap.score = {
              $meta: 'textScore'
            };
          } else if (field[0] == '-') {
            sortMap[field.slice(1)] = -1;
          } else {
            sortMap[field] = 1;
          }

          return sortMap;
        }, {});
        break;

      case 'include':
        {
          const paths = restOptions.include.split(',');

          if (paths.includes('*')) {
            this.includeAll = true;
            break;
          } // Load the existing includes (from keys)


          const pathSet = paths.reduce((memo, path) => {
            // Split each paths on . (a.b.c -> [a,b,c])
            // reduce to create all paths
            // ([a,b,c] -> {a: true, 'a.b': true, 'a.b.c': true})
            return path.split('.').reduce((memo, path, index, parts) => {
              memo[parts.slice(0, index + 1).join('.')] = true;
              return memo;
            }, memo);
          }, {});
          this.include = Object.keys(pathSet).map(s => {
            return s.split('.');
          }).sort((a, b) => {
            return a.length - b.length; // Sort by number of components
          });
          break;
        }

      case 'redirectClassNameForKey':
        this.redirectKey = restOptions.redirectClassNameForKey;
        this.redirectClassName = null;
        break;

      case 'includeReadPreference':
      case 'subqueryReadPreference':
        break;

      default:
        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad option: ' + option);
    }
  }
} // A convenient method to perform all the steps of processing a query
// in order.
// Returns a promise for the response - an object with optional keys
// 'results' and 'count'.
// TODO: consolidate the replaceX functions


_UnsafeRestQuery.prototype.execute = function (executeOptions) {
  return Promise.resolve().then(() => {
    return this.buildRestWhere();
  }).then(() => {
    return this.denyProtectedFields();
  }).then(() => {
    return this.handleIncludeAll();
  }).then(() => {
    return this.handleExcludeKeys();
  }).then(() => {
    return this.runFind(executeOptions);
  }).then(() => {
    return this.runCount();
  }).then(() => {
    return this.handleInclude();
  }).then(() => {
    return this.runAfterFindTrigger();
  }).then(() => {
    return this.response;
  });
};

_UnsafeRestQuery.prototype.each = function (callback) {
  const {
    config,
    auth,
    className,
    restWhere,
    restOptions,
    clientSDK
  } = this; // if the limit is set, use it

  restOptions.limit = restOptions.limit || 100;
  restOptions.order = 'objectId';
  let finished = false;
  return continueWhile(() => {
    return !finished;
  }, async () => {
    // Safe here to use _UnsafeRestQuery because the security was already
    // checked during "await RestQuery()"
    const query = new _UnsafeRestQuery(config, auth, className, restWhere, restOptions, clientSDK, this.runAfterFind, this.context);
    const {
      results
    } = await query.execute();
    results.forEach(callback);
    finished = results.length < restOptions.limit;

    if (!finished) {
      restWhere.objectId = Object.assign({}, restWhere.objectId, {
        $gt: results[results.length - 1].objectId
      });
    }
  });
};

_UnsafeRestQuery.prototype.buildRestWhere = function () {
  return Promise.resolve().then(() => {
    return this.getUserAndRoleACL();
  }).then(() => {
    return this.redirectClassNameForKey();
  }).then(() => {
    return this.validateClientClassCreation();
  }).then(() => {
    return this.replaceSelect();
  }).then(() => {
    return this.replaceDontSelect();
  }).then(() => {
    return this.replaceInQuery();
  }).then(() => {
    return this.replaceNotInQuery();
  }).then(() => {
    return this.replaceEquality();
  });
}; // Uses the Auth object to get the list of roles, adds the user id


_UnsafeRestQuery.prototype.getUserAndRoleACL = function () {
  if (this.auth.isMaster) {
    return Promise.resolve();
  }

  this.findOptions.acl = ['*'];

  if (this.auth.user) {
    return this.auth.getUserRoles().then(roles => {
      this.findOptions.acl = this.findOptions.acl.concat(roles, [this.auth.user.id]);
      return;
    });
  } else {
    return Promise.resolve();
  }
}; // Changes the className if redirectClassNameForKey is set.
// Returns a promise.


_UnsafeRestQuery.prototype.redirectClassNameForKey = function () {
  if (!this.redirectKey) {
    return Promise.resolve();
  } // We need to change the class name based on the schema


  return this.config.database.redirectClassNameForKey(this.className, this.redirectKey).then(newClassName => {
    this.className = newClassName;
    this.redirectClassName = newClassName;
  });
}; // Validates this operation against the allowClientClassCreation config.


_UnsafeRestQuery.prototype.validateClientClassCreation = function () {
  if (this.config.allowClientClassCreation === false && !this.auth.isMaster && SchemaController.systemClasses.indexOf(this.className) === -1) {
    return this.config.database.loadSchema().then(schemaController => schemaController.hasClass(this.className)).then(hasClass => {
      if (hasClass !== true) {
        throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'This user is not allowed to access ' + 'non-existent class: ' + this.className);
      }
    });
  } else {
    return Promise.resolve();
  }
};

function transformInQuery(inQueryObject, className, results) {
  var values = [];

  for (var result of results) {
    values.push({
      __type: 'Pointer',
      className: className,
      objectId: result.objectId
    });
  }

  delete inQueryObject['$inQuery'];

  if (Array.isArray(inQueryObject['$in'])) {
    inQueryObject['$in'] = inQueryObject['$in'].concat(values);
  } else {
    inQueryObject['$in'] = values;
  }
} // Replaces a $inQuery clause by running the subquery, if there is an
// $inQuery clause.
// The $inQuery clause turns into an $in with values that are just
// pointers to the objects returned in the subquery.


_UnsafeRestQuery.prototype.replaceInQuery = async function () {
  var inQueryObject = findObjectWithKey(this.restWhere, '$inQuery');

  if (!inQueryObject) {
    return;
  } // The inQuery value must have precisely two keys - where and className


  var inQueryValue = inQueryObject['$inQuery'];

  if (!inQueryValue.where || !inQueryValue.className) {
    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $inQuery');
  }

  const additionalOptions = {
    redirectClassNameForKey: inQueryValue.redirectClassNameForKey
  };

  if (this.restOptions.subqueryReadPreference) {
    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;
    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;
  } else if (this.restOptions.readPreference) {
    additionalOptions.readPreference = this.restOptions.readPreference;
  }

  const subquery = await RestQuery({
    method: RestQuery.Method.find,
    config: this.config,
    auth: this.auth,
    className: inQueryValue.className,
    restWhere: inQueryValue.where,
    restOptions: additionalOptions
  });
  return subquery.execute().then(response => {
    transformInQuery(inQueryObject, subquery.className, response.results); // Recurse to repeat

    return this.replaceInQuery();
  });
};

function transformNotInQuery(notInQueryObject, className, results) {
  var values = [];

  for (var result of results) {
    values.push({
      __type: 'Pointer',
      className: className,
      objectId: result.objectId
    });
  }

  delete notInQueryObject['$notInQuery'];

  if (Array.isArray(notInQueryObject['$nin'])) {
    notInQueryObject['$nin'] = notInQueryObject['$nin'].concat(values);
  } else {
    notInQueryObject['$nin'] = values;
  }
} // Replaces a $notInQuery clause by running the subquery, if there is an
// $notInQuery clause.
// The $notInQuery clause turns into a $nin with values that are just
// pointers to the objects returned in the subquery.


_UnsafeRestQuery.prototype.replaceNotInQuery = async function () {
  var notInQueryObject = findObjectWithKey(this.restWhere, '$notInQuery');

  if (!notInQueryObject) {
    return;
  } // The notInQuery value must have precisely two keys - where and className


  var notInQueryValue = notInQueryObject['$notInQuery'];

  if (!notInQueryValue.where || !notInQueryValue.className) {
    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $notInQuery');
  }

  const additionalOptions = {
    redirectClassNameForKey: notInQueryValue.redirectClassNameForKey
  };

  if (this.restOptions.subqueryReadPreference) {
    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;
    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;
  } else if (this.restOptions.readPreference) {
    additionalOptions.readPreference = this.restOptions.readPreference;
  }

  const subquery = await RestQuery({
    method: RestQuery.Method.find,
    config: this.config,
    auth: this.auth,
    className: notInQueryValue.className,
    restWhere: notInQueryValue.where,
    restOptions: additionalOptions
  });
  return subquery.execute().then(response => {
    transformNotInQuery(notInQueryObject, subquery.className, response.results); // Recurse to repeat

    return this.replaceNotInQuery();
  });
}; // Used to get the deepest object from json using dot notation.


const getDeepestObjectFromKey = (json, key, idx, src) => {
  if (key in json) {
    return json[key];
  }

  src.splice(1); // Exit Early
};

const transformSelect = (selectObject, key, objects) => {
  var values = [];

  for (var result of objects) {
    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));
  }

  delete selectObject['$select'];

  if (Array.isArray(selectObject['$in'])) {
    selectObject['$in'] = selectObject['$in'].concat(values);
  } else {
    selectObject['$in'] = values;
  }
}; // Replaces a $select clause by running the subquery, if there is a
// $select clause.
// The $select clause turns into an $in with values selected out of
// the subquery.
// Returns a possible-promise.


_UnsafeRestQuery.prototype.replaceSelect = async function () {
  var selectObject = findObjectWithKey(this.restWhere, '$select');

  if (!selectObject) {
    return;
  } // The select value must have precisely two keys - query and key


  var selectValue = selectObject['$select']; // iOS SDK don't send where if not set, let it pass

  if (!selectValue.query || !selectValue.key || typeof selectValue.query !== 'object' || !selectValue.query.className || Object.keys(selectValue).length !== 2) {
    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $select');
  }

  const additionalOptions = {
    redirectClassNameForKey: selectValue.query.redirectClassNameForKey
  };

  if (this.restOptions.subqueryReadPreference) {
    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;
    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;
  } else if (this.restOptions.readPreference) {
    additionalOptions.readPreference = this.restOptions.readPreference;
  }

  const subquery = await RestQuery({
    method: RestQuery.Method.find,
    config: this.config,
    auth: this.auth,
    className: selectValue.query.className,
    restWhere: selectValue.query.where,
    restOptions: additionalOptions
  });
  return subquery.execute().then(response => {
    transformSelect(selectObject, selectValue.key, response.results); // Keep replacing $select clauses

    return this.replaceSelect();
  });
};

const transformDontSelect = (dontSelectObject, key, objects) => {
  var values = [];

  for (var result of objects) {
    values.push(key.split('.').reduce(getDeepestObjectFromKey, result));
  }

  delete dontSelectObject['$dontSelect'];

  if (Array.isArray(dontSelectObject['$nin'])) {
    dontSelectObject['$nin'] = dontSelectObject['$nin'].concat(values);
  } else {
    dontSelectObject['$nin'] = values;
  }
}; // Replaces a $dontSelect clause by running the subquery, if there is a
// $dontSelect clause.
// The $dontSelect clause turns into an $nin with values selected out of
// the subquery.
// Returns a possible-promise.


_UnsafeRestQuery.prototype.replaceDontSelect = async function () {
  var dontSelectObject = findObjectWithKey(this.restWhere, '$dontSelect');

  if (!dontSelectObject) {
    return;
  } // The dontSelect value must have precisely two keys - query and key


  var dontSelectValue = dontSelectObject['$dontSelect'];

  if (!dontSelectValue.query || !dontSelectValue.key || typeof dontSelectValue.query !== 'object' || !dontSelectValue.query.className || Object.keys(dontSelectValue).length !== 2) {
    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'improper usage of $dontSelect');
  }

  const additionalOptions = {
    redirectClassNameForKey: dontSelectValue.query.redirectClassNameForKey
  };

  if (this.restOptions.subqueryReadPreference) {
    additionalOptions.readPreference = this.restOptions.subqueryReadPreference;
    additionalOptions.subqueryReadPreference = this.restOptions.subqueryReadPreference;
  } else if (this.restOptions.readPreference) {
    additionalOptions.readPreference = this.restOptions.readPreference;
  }

  const subquery = await RestQuery({
    method: RestQuery.Method.find,
    config: this.config,
    auth: this.auth,
    className: dontSelectValue.query.className,
    restWhere: dontSelectValue.query.where,
    restOptions: additionalOptions
  });
  return subquery.execute().then(response => {
    transformDontSelect(dontSelectObject, dontSelectValue.key, response.results); // Keep replacing $dontSelect clauses

    return this.replaceDontSelect();
  });
};

_UnsafeRestQuery.prototype.cleanResultAuthData = function (result) {
  delete result.password;

  if (result.authData) {
    Object.keys(result.authData).forEach(provider => {
      if (result.authData[provider] === null) {
        delete result.authData[provider];
      }
    });

    if (Object.keys(result.authData).length == 0) {
      delete result.authData;
    }
  }
};

const replaceEqualityConstraint = constraint => {
  if (typeof constraint !== 'object') {
    return constraint;
  }

  const equalToObject = {};
  let hasDirectConstraint = false;
  let hasOperatorConstraint = false;

  for (const key in constraint) {
    if (key.indexOf('$') !== 0) {
      hasDirectConstraint = true;
      equalToObject[key] = constraint[key];
    } else {
      hasOperatorConstraint = true;
    }
  }

  if (hasDirectConstraint && hasOperatorConstraint) {
    constraint['$eq'] = equalToObject;
    Object.keys(equalToObject).forEach(key => {
      delete constraint[key];
    });
  }

  return constraint;
};

_UnsafeRestQuery.prototype.replaceEquality = function () {
  if (typeof this.restWhere !== 'object') {
    return;
  }

  for (const key in this.restWhere) {
    this.restWhere[key] = replaceEqualityConstraint(this.restWhere[key]);
  }
}; // Returns a promise for whether it was successful.
// Populates this.response with an object that only has 'results'.


_UnsafeRestQuery.prototype.runFind = function (options = {}) {
  if (this.findOptions.limit === 0) {
    this.response = {
      results: []
    };
    return Promise.resolve();
  }

  const findOptions = Object.assign({}, this.findOptions);

  if (this.keys) {
    findOptions.keys = this.keys.map(key => {
      return key.split('.')[0];
    });
  }

  if (options.op) {
    findOptions.op = options.op;
  }

  return this.config.database.find(this.className, this.restWhere, findOptions, this.auth).then(results => {
    if (this.className === '_User' && !findOptions.explain) {
      for (var result of results) {
        this.cleanResultAuthData(result);
      }
    }

    this.config.filesController.expandFilesInObject(this.config, results);

    if (this.redirectClassName) {
      for (var r of results) {
        r.className = this.redirectClassName;
      }
    }

    this.response = {
      results: results
    };
  });
}; // Returns a promise for whether it was successful.
// Populates this.response.count with the count


_UnsafeRestQuery.prototype.runCount = function () {
  if (!this.doCount) {
    return;
  }

  this.findOptions.count = true;
  delete this.findOptions.skip;
  delete this.findOptions.limit;
  return this.config.database.find(this.className, this.restWhere, this.findOptions).then(c => {
    this.response.count = c;
  });
};

_UnsafeRestQuery.prototype.denyProtectedFields = async function () {
  if (this.auth.isMaster) {
    return;
  }

  const schemaController = await this.config.database.loadSchema();
  const protectedFields = this.config.database.addProtectedFields(schemaController, this.className, this.restWhere, this.findOptions.acl, this.auth, this.findOptions) || [];

  for (const key of protectedFields) {
    if (this.restWhere[key]) {
      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, `This user is not allowed to query ${key} on class ${this.className}`);
    }
  }
}; // Augments this.response with all pointers on an object


_UnsafeRestQuery.prototype.handleIncludeAll = function () {
  if (!this.includeAll) {
    return;
  }

  return this.config.database.loadSchema().then(schemaController => schemaController.getOneSchema(this.className)).then(schema => {
    const includeFields = [];
    const keyFields = [];

    for (const field in schema.fields) {
      if (schema.fields[field].type && schema.fields[field].type === 'Pointer' || schema.fields[field].type && schema.fields[field].type === 'Array') {
        includeFields.push([field]);
        keyFields.push(field);
      }
    } // Add fields to include, keys, remove dups


    this.include = [...new Set([...this.include, ...includeFields])]; // if this.keys not set, then all keys are already included

    if (this.keys) {
      this.keys = [...new Set([...this.keys, ...keyFields])];
    }
  });
}; // Updates property `this.keys` to contain all keys but the ones unselected.


_UnsafeRestQuery.prototype.handleExcludeKeys = function () {
  if (!this.excludeKeys) {
    return;
  }

  if (this.keys) {
    this.keys = this.keys.filter(k => !this.excludeKeys.includes(k));
    return;
  }

  return this.config.database.loadSchema().then(schemaController => schemaController.getOneSchema(this.className)).then(schema => {
    const fields = Object.keys(schema.fields);
    this.keys = fields.filter(k => !this.excludeKeys.includes(k));
  });
}; // Augments this.response with data at the paths provided in this.include.


_UnsafeRestQuery.prototype.handleInclude = function () {
  if (this.include.length == 0) {
    return;
  }

  var pathResponse = includePath(this.config, this.auth, this.response, this.include[0], this.restOptions);

  if (pathResponse.then) {
    return pathResponse.then(newResponse => {
      this.response = newResponse;
      this.include = this.include.slice(1);
      return this.handleInclude();
    });
  } else if (this.include.length > 0) {
    this.include = this.include.slice(1);
    return this.handleInclude();
  }

  return pathResponse;
}; //Returns a promise of a processed set of results


_UnsafeRestQuery.prototype.runAfterFindTrigger = function () {
  if (!this.response) {
    return;
  }

  if (!this.runAfterFind) {
    return;
  } // Avoid doing any setup for triggers if there is no 'afterFind' trigger for this class.


  const hasAfterFindHook = triggers.triggerExists(this.className, triggers.Types.afterFind, this.config.applicationId);

  if (!hasAfterFindHook) {
    return Promise.resolve();
  } // Skip Aggregate and Distinct Queries


  if (this.findOptions.pipeline || this.findOptions.distinct) {
    return Promise.resolve();
  }

  const json = Object.assign({}, this.restOptions);
  json.where = this.restWhere;
  const parseQuery = new Parse.Query(this.className);
  parseQuery.withJSON(json); // Run afterFind trigger and set the new results

  return triggers.maybeRunAfterFindTrigger(triggers.Types.afterFind, this.auth, this.className, this.response.results, this.config, parseQuery, this.context).then(results => {
    // Ensure we properly set the className back
    if (this.redirectClassName) {
      this.response.results = results.map(object => {
        if (object instanceof Parse.Object) {
          object = object.toJSON();
        }

        object.className = this.redirectClassName;
        return object;
      });
    } else {
      this.response.results = results;
    }
  });
}; // Adds included values to the response.
// Path is a list of field names.
// Returns a promise for an augmented response.


function includePath(config, auth, response, path, restOptions = {}) {
  var pointers = findPointers(response.results, path);

  if (pointers.length == 0) {
    return response;
  }

  const pointersHash = {};

  for (var pointer of pointers) {
    if (!pointer) {
      continue;
    }

    const className = pointer.className; // only include the good pointers

    if (className) {
      pointersHash[className] = pointersHash[className] || new Set();
      pointersHash[className].add(pointer.objectId);
    }
  }

  const includeRestOptions = {};

  if (restOptions.keys) {
    const keys = new Set(restOptions.keys.split(','));
    const keySet = Array.from(keys).reduce((set, key) => {
      const keyPath = key.split('.');
      let i = 0;

      for (i; i < path.length; i++) {
        if (path[i] != keyPath[i]) {
          return set;
        }
      }

      if (i < keyPath.length) {
        set.add(keyPath[i]);
      }

      return set;
    }, new Set());

    if (keySet.size > 0) {
      includeRestOptions.keys = Array.from(keySet).join(',');
    }
  }

  if (restOptions.excludeKeys) {
    const excludeKeys = new Set(restOptions.excludeKeys.split(','));
    const excludeKeySet = Array.from(excludeKeys).reduce((set, key) => {
      const keyPath = key.split('.');
      let i = 0;

      for (i; i < path.length; i++) {
        if (path[i] != keyPath[i]) {
          return set;
        }
      }

      if (i == keyPath.length - 1) {
        set.add(keyPath[i]);
      }

      return set;
    }, new Set());

    if (excludeKeySet.size > 0) {
      includeRestOptions.excludeKeys = Array.from(excludeKeySet).join(',');
    }
  }

  if (restOptions.includeReadPreference) {
    includeRestOptions.readPreference = restOptions.includeReadPreference;
    includeRestOptions.includeReadPreference = restOptions.includeReadPreference;
  } else if (restOptions.readPreference) {
    includeRestOptions.readPreference = restOptions.readPreference;
  }

  const queryPromises = Object.keys(pointersHash).map(async className => {
    const objectIds = Array.from(pointersHash[className]);
    let where;

    if (objectIds.length === 1) {
      where = {
        objectId: objectIds[0]
      };
    } else {
      where = {
        objectId: {
          $in: objectIds
        }
      };
    }

    const query = await RestQuery({
      method: objectIds.length === 1 ? RestQuery.Method.get : RestQuery.Method.find,
      config,
      auth,
      className,
      restWhere: where,
      restOptions: includeRestOptions
    });
    return query.execute({
      op: 'get'
    }).then(results => {
      results.className = className;
      return Promise.resolve(results);
    });
  }); // Get the objects for all these object ids

  return Promise.all(queryPromises).then(responses => {
    var replace = responses.reduce((replace, includeResponse) => {
      for (var obj of includeResponse.results) {
        obj.__type = 'Object';
        obj.className = includeResponse.className;

        if (obj.className == '_User' && !auth.isMaster) {
          delete obj.sessionToken;
          delete obj.authData;
        }

        replace[obj.objectId] = obj;
      }

      return replace;
    }, {});
    var resp = {
      results: replacePointers(response.results, path, replace)
    };

    if (response.count) {
      resp.count = response.count;
    }

    return resp;
  });
} // Object may be a list of REST-format object to find pointers in, or
// it may be a single object.
// If the path yields things that aren't pointers, this throws an error.
// Path is a list of fields to search into.
// Returns a list of pointers in REST format.


function findPointers(object, path) {
  if (object instanceof Array) {
    var answer = [];

    for (var x of object) {
      answer = answer.concat(findPointers(x, path));
    }

    return answer;
  }

  if (typeof object !== 'object' || !object) {
    return [];
  }

  if (path.length == 0) {
    if (object === null || object.__type == 'Pointer') {
      return [object];
    }

    return [];
  }

  var subobject = object[path[0]];

  if (!subobject) {
    return [];
  }

  return findPointers(subobject, path.slice(1));
} // Object may be a list of REST-format objects to replace pointers
// in, or it may be a single object.
// Path is a list of fields to search into.
// replace is a map from object id -> object.
// Returns something analogous to object, but with the appropriate
// pointers inflated.


function replacePointers(object, path, replace) {
  if (object instanceof Array) {
    return object.map(obj => replacePointers(obj, path, replace)).filter(obj => typeof obj !== 'undefined');
  }

  if (typeof object !== 'object' || !object) {
    return object;
  }

  if (path.length === 0) {
    if (object && object.__type === 'Pointer') {
      return replace[object.objectId];
    }

    return object;
  }

  var subobject = object[path[0]];

  if (!subobject) {
    return object;
  }

  var newsub = replacePointers(subobject, path.slice(1), replace);
  var answer = {};

  for (var key in object) {
    if (key == path[0]) {
      answer[key] = newsub;
    } else {
      answer[key] = object[key];
    }
  }

  return answer;
} // Finds a subobject that has the given key, if there is one.
// Returns undefined otherwise.


function findObjectWithKey(root, key) {
  if (typeof root !== 'object') {
    return;
  }

  if (root instanceof Array) {
    for (var item of root) {
      const answer = findObjectWithKey(item, key);

      if (answer) {
        return answer;
      }
    }
  }

  if (root && root[key]) {
    return root;
  }

  for (var subkey in root) {
    const answer = findObjectWithKey(root[subkey], key);

    if (answer) {
      return answer;
    }
  }
}

module.exports = RestQuery; // For tests

module.exports._UnsafeRestQuery = _UnsafeRestQuery;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZXN0UXVlcnkuanMiXSwibmFtZXMiOlsiU2NoZW1hQ29udHJvbGxlciIsInJlcXVpcmUiLCJQYXJzZSIsInRyaWdnZXJzIiwiY29udGludWVXaGlsZSIsIkFsd2F5c1NlbGVjdGVkS2V5cyIsImVuZm9yY2VSb2xlU2VjdXJpdHkiLCJSZXN0UXVlcnkiLCJtZXRob2QiLCJjb25maWciLCJhdXRoIiwiY2xhc3NOYW1lIiwicmVzdFdoZXJlIiwicmVzdE9wdGlvbnMiLCJjbGllbnRTREsiLCJydW5BZnRlckZpbmQiLCJydW5CZWZvcmVGaW5kIiwiY29udGV4dCIsIk1ldGhvZCIsImZpbmQiLCJnZXQiLCJpbmNsdWRlcyIsIkVycm9yIiwiSU5WQUxJRF9RVUVSWSIsInJlc3VsdCIsIm1heWJlUnVuUXVlcnlUcmlnZ2VyIiwiVHlwZXMiLCJiZWZvcmVGaW5kIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfVW5zYWZlUmVzdFF1ZXJ5IiwiT2JqZWN0IiwiZnJlZXplIiwicmVzcG9uc2UiLCJmaW5kT3B0aW9ucyIsImlzTWFzdGVyIiwidXNlciIsIklOVkFMSURfU0VTU0lPTl9UT0tFTiIsIiRhbmQiLCJfX3R5cGUiLCJvYmplY3RJZCIsImlkIiwiZG9Db3VudCIsImluY2x1ZGVBbGwiLCJpbmNsdWRlIiwia2V5c0ZvckluY2x1ZGUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrZXlzIiwiZXhjbHVkZUtleXMiLCJsZW5ndGgiLCJzcGxpdCIsImZpbHRlciIsImtleSIsIm1hcCIsInNsaWNlIiwibGFzdEluZGV4T2YiLCJqb2luIiwib3B0aW9uIiwiY29uY2F0IiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZXhjbHVkZSIsImsiLCJpbmRleE9mIiwiZmllbGRzIiwib3JkZXIiLCJzb3J0IiwicmVkdWNlIiwic29ydE1hcCIsImZpZWxkIiwidHJpbSIsInNjb3JlIiwiJG1ldGEiLCJwYXRocyIsInBhdGhTZXQiLCJtZW1vIiwicGF0aCIsImluZGV4IiwicGFydHMiLCJzIiwiYSIsImIiLCJyZWRpcmVjdEtleSIsInJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5IiwicmVkaXJlY3RDbGFzc05hbWUiLCJJTlZBTElEX0pTT04iLCJleGVjdXRlIiwiZXhlY3V0ZU9wdGlvbnMiLCJ0aGVuIiwiYnVpbGRSZXN0V2hlcmUiLCJkZW55UHJvdGVjdGVkRmllbGRzIiwiaGFuZGxlSW5jbHVkZUFsbCIsImhhbmRsZUV4Y2x1ZGVLZXlzIiwicnVuRmluZCIsInJ1bkNvdW50IiwiaGFuZGxlSW5jbHVkZSIsInJ1bkFmdGVyRmluZFRyaWdnZXIiLCJlYWNoIiwiY2FsbGJhY2siLCJsaW1pdCIsImZpbmlzaGVkIiwicXVlcnkiLCJyZXN1bHRzIiwiZm9yRWFjaCIsImFzc2lnbiIsIiRndCIsImdldFVzZXJBbmRSb2xlQUNMIiwidmFsaWRhdGVDbGllbnRDbGFzc0NyZWF0aW9uIiwicmVwbGFjZVNlbGVjdCIsInJlcGxhY2VEb250U2VsZWN0IiwicmVwbGFjZUluUXVlcnkiLCJyZXBsYWNlTm90SW5RdWVyeSIsInJlcGxhY2VFcXVhbGl0eSIsImFjbCIsImdldFVzZXJSb2xlcyIsInJvbGVzIiwiZGF0YWJhc2UiLCJuZXdDbGFzc05hbWUiLCJhbGxvd0NsaWVudENsYXNzQ3JlYXRpb24iLCJzeXN0ZW1DbGFzc2VzIiwibG9hZFNjaGVtYSIsInNjaGVtYUNvbnRyb2xsZXIiLCJoYXNDbGFzcyIsIk9QRVJBVElPTl9GT1JCSURERU4iLCJ0cmFuc2Zvcm1JblF1ZXJ5IiwiaW5RdWVyeU9iamVjdCIsInZhbHVlcyIsInB1c2giLCJpc0FycmF5IiwiZmluZE9iamVjdFdpdGhLZXkiLCJpblF1ZXJ5VmFsdWUiLCJ3aGVyZSIsImFkZGl0aW9uYWxPcHRpb25zIiwic3VicXVlcnlSZWFkUHJlZmVyZW5jZSIsInJlYWRQcmVmZXJlbmNlIiwic3VicXVlcnkiLCJ0cmFuc2Zvcm1Ob3RJblF1ZXJ5Iiwibm90SW5RdWVyeU9iamVjdCIsIm5vdEluUXVlcnlWYWx1ZSIsImdldERlZXBlc3RPYmplY3RGcm9tS2V5IiwianNvbiIsImlkeCIsInNyYyIsInNwbGljZSIsInRyYW5zZm9ybVNlbGVjdCIsInNlbGVjdE9iamVjdCIsIm9iamVjdHMiLCJzZWxlY3RWYWx1ZSIsInRyYW5zZm9ybURvbnRTZWxlY3QiLCJkb250U2VsZWN0T2JqZWN0IiwiZG9udFNlbGVjdFZhbHVlIiwiY2xlYW5SZXN1bHRBdXRoRGF0YSIsInBhc3N3b3JkIiwiYXV0aERhdGEiLCJwcm92aWRlciIsInJlcGxhY2VFcXVhbGl0eUNvbnN0cmFpbnQiLCJjb25zdHJhaW50IiwiZXF1YWxUb09iamVjdCIsImhhc0RpcmVjdENvbnN0cmFpbnQiLCJoYXNPcGVyYXRvckNvbnN0cmFpbnQiLCJvcHRpb25zIiwib3AiLCJleHBsYWluIiwiZmlsZXNDb250cm9sbGVyIiwiZXhwYW5kRmlsZXNJbk9iamVjdCIsInIiLCJjb3VudCIsInNraXAiLCJjIiwicHJvdGVjdGVkRmllbGRzIiwiYWRkUHJvdGVjdGVkRmllbGRzIiwiZ2V0T25lU2NoZW1hIiwic2NoZW1hIiwiaW5jbHVkZUZpZWxkcyIsImtleUZpZWxkcyIsInR5cGUiLCJwYXRoUmVzcG9uc2UiLCJpbmNsdWRlUGF0aCIsIm5ld1Jlc3BvbnNlIiwiaGFzQWZ0ZXJGaW5kSG9vayIsInRyaWdnZXJFeGlzdHMiLCJhZnRlckZpbmQiLCJhcHBsaWNhdGlvbklkIiwicGlwZWxpbmUiLCJkaXN0aW5jdCIsInBhcnNlUXVlcnkiLCJRdWVyeSIsIndpdGhKU09OIiwibWF5YmVSdW5BZnRlckZpbmRUcmlnZ2VyIiwib2JqZWN0IiwidG9KU09OIiwicG9pbnRlcnMiLCJmaW5kUG9pbnRlcnMiLCJwb2ludGVyc0hhc2giLCJwb2ludGVyIiwiYWRkIiwiaW5jbHVkZVJlc3RPcHRpb25zIiwia2V5U2V0Iiwic2V0Iiwia2V5UGF0aCIsImkiLCJzaXplIiwiZXhjbHVkZUtleVNldCIsImluY2x1ZGVSZWFkUHJlZmVyZW5jZSIsInF1ZXJ5UHJvbWlzZXMiLCJvYmplY3RJZHMiLCIkaW4iLCJhbGwiLCJyZXNwb25zZXMiLCJyZXBsYWNlIiwiaW5jbHVkZVJlc3BvbnNlIiwib2JqIiwic2Vzc2lvblRva2VuIiwicmVzcCIsInJlcGxhY2VQb2ludGVycyIsImFuc3dlciIsIngiLCJzdWJvYmplY3QiLCJuZXdzdWIiLCJyb290IiwiaXRlbSIsInN1YmtleSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUVBLElBQUlBLGdCQUFnQixHQUFHQyxPQUFPLENBQUMsZ0NBQUQsQ0FBOUI7O0FBQ0EsSUFBSUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsWUFBRCxDQUFQLENBQXNCQyxLQUFsQzs7QUFDQSxNQUFNQyxRQUFRLEdBQUdGLE9BQU8sQ0FBQyxZQUFELENBQXhCOztBQUNBLE1BQU07QUFBRUcsRUFBQUE7QUFBRixJQUFvQkgsT0FBTyxDQUFDLDZCQUFELENBQWpDOztBQUNBLE1BQU1JLGtCQUFrQixHQUFHLENBQUMsVUFBRCxFQUFhLFdBQWIsRUFBMEIsV0FBMUIsRUFBdUMsS0FBdkMsQ0FBM0I7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQTtBQUFGLElBQTBCTCxPQUFPLENBQUMsY0FBRCxDQUF2QyxDLENBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsZUFBZU0sU0FBZixDQUF5QjtBQUN2QkMsRUFBQUEsTUFEdUI7QUFFdkJDLEVBQUFBLE1BRnVCO0FBR3ZCQyxFQUFBQSxJQUh1QjtBQUl2QkMsRUFBQUEsU0FKdUI7QUFLdkJDLEVBQUFBLFNBQVMsR0FBRyxFQUxXO0FBTXZCQyxFQUFBQSxXQUFXLEdBQUcsRUFOUztBQU92QkMsRUFBQUEsU0FQdUI7QUFRdkJDLEVBQUFBLFlBQVksR0FBRyxJQVJRO0FBU3ZCQyxFQUFBQSxhQUFhLEdBQUcsSUFUTztBQVV2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SUFBSSxZQUFZakssS0FBcEIsRUFBMkI7QUFDekIsU0FBSyxJQUFJa0ssSUFBVCxJQUFpQkQsSUFBakIsRUFBdUI7QUFDckIsWUFBTUosTUFBTSxHQUFHdEYsaUJBQWlCLENBQUMyRixJQUFELEVBQU96SyxHQUFQLENBQWhDOztBQUNBLFVBQUlvSyxNQUFKLEVBQVk7QUFDVixlQUFPQSxNQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUNELE1BQUlJLElBQUksSUFBSUEsSUFBSSxDQUFDeEssR0FBRCxDQUFoQixFQUF1QjtBQUNyQixXQUFPd0ssSUFBUDtBQUNEOztBQUNELE9BQUssSUFBSUUsTUFBVCxJQUFtQkYsSUFBbkIsRUFBeUI7QUFDdkIsVUFBTUosTUFBTSxHQUFHdEYsaUJBQWlCLENBQUMwRixJQUFJLENBQUNFLE1BQUQsQ0FBTCxFQUFlMUssR0FBZixDQUFoQzs7QUFDQSxRQUFJb0ssTUFBSixFQUFZO0FBQ1YsYUFBT0EsTUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRE8sTUFBTSxDQUFDQyxPQUFQLEdBQWlCM04sU0FBakIsQyxDQUNBOztBQUNBME4sTUFBTSxDQUFDQyxPQUFQLENBQWVwTSxnQkFBZixHQUFrQ0EsZ0JBQWxDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQW4gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCB0byBydW4gYSAnZmluZCdcbi8vIG9wZXJhdGlvbiwgZW5jb2RlZCBpbiB0aGUgUkVTVCBBUEkgZm9ybWF0LlxuXG52YXIgU2NoZW1hQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vQ29udHJvbGxlcnMvU2NoZW1hQ29udHJvbGxlcicpO1xudmFyIFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpLlBhcnNlO1xuY29uc3QgdHJpZ2dlcnMgPSByZXF1aXJlKCcuL3RyaWdnZXJzJyk7XG5jb25zdCB7IGNvbnRpbnVlV2hpbGUgfSA9IHJlcXVpcmUoJ3BhcnNlL2xpYi9ub2RlL3Byb21pc2VVdGlscycpO1xuY29uc3QgQWx3YXlzU2VsZWN0ZWRLZXlzID0gWydvYmplY3RJZCcsICdjcmVhdGVkQXQnLCAndXBkYXRlZEF0JywgJ0FDTCddO1xuY29uc3QgeyBlbmZvcmNlUm9sZVNlY3VyaXR5IH0gPSByZXF1aXJlKCcuL1NoYXJlZFJlc3QnKTtcblxuLy8gcmVzdE9wdGlvbnMgY2FuIGluY2x1ZGU6XG4vLyAgIHNraXBcbi8vICAgbGltaXRcbi8vICAgb3JkZXJcbi8vICAgY291bnRcbi8vICAgaW5jbHVkZVxuLy8gICBrZXlzXG4vLyAgIGV4Y2x1ZGVLZXlzXG4vLyAgIHJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5XG4vLyAgIHJlYWRQcmVmZXJlbmNlXG4vLyAgIGluY2x1ZGVSZWFkUHJlZmVyZW5jZVxuLy8gICBzdWJxdWVyeVJlYWRQcmVmZXJlbmNlXG4vKipcbiAqIFVzZSB0byBwZXJmb3JtIGEgcXVlcnkgb24gYSBjbGFzcy4gSXQgd2lsbCBydW4gc2VjdXJpdHkgY2hlY2tzIGFuZCB0cmlnZ2Vycy5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy5tZXRob2Qge1Jlc3RRdWVyeS5NZXRob2R9IFRoZSB0eXBlIG9mIHF1ZXJ5IHRvIHBlcmZvcm1cbiAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyB7UGFyc2VTZXJ2ZXJDb25maWd1cmF0aW9ufSBUaGUgc2VydmVyIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBvcHRpb25zLmF1dGgge0F1dGh9IFRoZSBhdXRoIG9iamVjdCBmb3IgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSBvcHRpb25zLmNsYXNzTmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gcXVlcnlcbiAqIEBwYXJhbSBvcHRpb25zLnJlc3RXaGVyZSB7b2JqZWN0fSBUaGUgd2hlcmUgb2JqZWN0IGZvciB0aGUgcXVlcnlcbiAqIEBwYXJhbSBvcHRpb25zLnJlc3RPcHRpb25zIHtvYmplY3R9IFRoZSBvcHRpb25zIG9iamVjdCBmb3IgdGhlIHF1ZXJ5XG4gKiBAcGFyYW0gb3B0aW9ucy5jbGllbnRTREsge3N0cmluZ30gVGhlIGNsaWVudCBTREsgdGhhdCBpcyBwZXJmb3JtaW5nIHRoZSBxdWVyeVxuICogQHBhcmFtIG9wdGlvbnMucnVuQWZ0ZXJGaW5kIHtib29sZWFufSBXaGV0aGVyIHRvIHJ1biB0aGUgYWZ0ZXJGaW5kIHRyaWdnZXJcbiAqIEBwYXJhbSBvcHRpb25zLnJ1bkJlZm9yZUZpbmQge2Jvb2xlYW59IFdoZXRoZXIgdG8gcnVuIHRoZSBiZWZvcmVGaW5kIHRyaWdnZXJcbiAqIEBwYXJhbSBvcHRpb25zLmNvbnRleHQge29iamVjdH0gVGhlIGNvbnRleHQgb2JqZWN0IGZvciB0aGUgcXVlcnlcbiAqIEByZXR1cm5zIHtQcm9taXNlPF9VbnNhZmVSZXN0UXVlcnk+fSBBIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aXRoIHRoZSBfVW5zYWZlUmVzdFF1ZXJ5IG9iamVjdFxuICovXG5hc3luYyBmdW5jdGlvbiBSZXN0UXVlcnkoe1xuICBtZXRob2QsXG4gIGNvbmZpZyxcbiAgYXV0aCxcbiAgY2xhc3NOYW1lLFxuICByZXN0V2hlcmUgPSB7fSxcbiAgcmVzdE9wdGlvbnMgPSB7fSxcbiAgY2xpZW50U0RLLFxuICBydW5BZnRlckZpbmQgPSB0cnVlLFxuICBydW5CZWZvcmVGaW5kID0gdHJ1ZSxcbiAgY29udGV4dCxcbn0pIHtcbiAgaWYgKCFbUmVzdFF1ZXJ5Lk1ldGhvZC5maW5kLCBSZXN0UXVlcnkuTWV0aG9kLmdldF0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5JTlZBTElEX1FVRVJZLCAnYmFkIHF1ZXJ5IHR5cGUnKTtcbiAgfVxuICBlbmZvcmNlUm9sZVNlY3VyaXR5KG1ldGhvZCwgY2xhc3NOYW1lLCBhdXRoKTtcbiAgY29uc3QgcmVzdWx0ID0gcnVuQmVmb3JlRmluZFxuICAgID8gYXdhaXQgdHJpZ2dlcnMubWF5YmVSdW5RdWVyeVRyaWdnZXIoXG4gICAgICB0cmlnZ2Vycy5UeXBlcy5iZWZvcmVGaW5kLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcmVzdFdoZXJlLFxuICAgICAgcmVzdE9wdGlvbnMsXG4gICAgICBjb25maWcsXG4gICAgICBhdXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIG1ldGhvZCA9PT0gUmVzdFF1ZXJ5Lk1ldGhvZC5nZXRcbiAgICApXG4gICAgOiBQcm9taXNlLnJlc29sdmUoeyByZXN0V2hlcmUsIHJlc3RPcHRpb25zIH0pO1xuXG4gIHJldHVybiBuZXcgX1Vuc2FmZVJlc3RRdWVyeShcbiAgICBjb25maWcsXG4gICAgYXV0aCxcbiAgICBjbGFzc05hbWUsXG4gICAgcmVzdWx0LnJlc3RXaGVyZSB8fCByZXN0V2hlcmUsXG4gICAgcmVzdWx0LnJlc3RPcHRpb25zIHx8IHJlc3RPcHRpb25zLFxuICAgIGNsaWVudFNESyxcbiAgICBydW5BZnRlckZpbmQsXG4gICAgY29udGV4dFxuICApO1xufVxuXG5SZXN0UXVlcnkuTWV0aG9kID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGdldDogJ2dldCcsXG4gIGZpbmQ6ICdmaW5kJyxcbn0pO1xuXG4vKipcbiAqIF9VbnNhZmVSZXN0UXVlcnkgaXMgbWVhbnQgZm9yIHNwZWNpZmljIGludGVybmFsIHVzYWdlIG9ubHkuIFdoZW4geW91IG5lZWQgdG8gc2tpcCBzZWN1cml0eSBjaGVja3Mgb3Igc29tZSB0cmlnZ2Vycy5cbiAqIERvbid0IHVzZSBpdCBpZiB5b3UgZG9uJ3Qga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gKiBAcGFyYW0gY29uZmlnXG4gKiBAcGFyYW0gYXV0aFxuICogQHBhcmFtIGNsYXNzTmFtZVxuICogQHBhcmFtIHJlc3RXaGVyZVxuICogQHBhcmFtIHJlc3RPcHRpb25zXG4gKiBAcGFyYW0gY2xpZW50U0RLXG4gKiBAcGFyYW0gcnVuQWZ0ZXJGaW5kXG4gKiBAcGFyYW0gY29udGV4dFxuICovXG5mdW5jdGlvbiBfVW5zYWZlUmVzdFF1ZXJ5KFxuICBjb25maWcsXG4gIGF1dGgsXG4gIGNsYXNzTmFtZSxcbiAgcmVzdFdoZXJlID0ge30sXG4gIHJlc3RPcHRpb25zID0ge30sXG4gIGNsaWVudFNESyxcbiAgcnVuQWZ0ZXJGaW5kID0gdHJ1ZSxcbiAgY29udGV4dFxuKSB7XG4gIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB0aGlzLmF1dGggPSBhdXRoO1xuICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgdGhpcy5yZXN0V2hlcmUgPSByZXN0V2hlcmU7XG4gIHRoaXMucmVzdE9wdGlvbnMgPSByZXN0T3B0aW9ucztcbiAgdGhpcy5jbGllbnRTREsgPSBjbGllbnRTREs7XG4gIHRoaXMucnVuQWZ0ZXJGaW5kID0gcnVuQWZ0ZXJGaW5kO1xuICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgdGhpcy5maW5kT3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuICBpZiAoIXRoaXMuYXV0aC5pc01hc3Rlcikge1xuICAgIGlmICh0aGlzLmNsYXNzTmFtZSA9PSAnX1Nlc3Npb24nKSB7XG4gICAgICBpZiAoIXRoaXMuYXV0aC51c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5JTlZBTElEX1NFU1NJT05fVE9LRU4sICdJbnZhbGlkIHNlc3Npb24gdG9rZW4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdFdoZXJlID0ge1xuICAgICAgICAkYW5kOiBbXG4gICAgICAgICAgdGhpcy5yZXN0V2hlcmUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnX1VzZXInLFxuICAgICAgICAgICAgICBvYmplY3RJZDogdGhpcy5hdXRoLnVzZXIuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZG9Db3VudCA9IGZhbHNlO1xuICB0aGlzLmluY2x1ZGVBbGwgPSBmYWxzZTtcblxuICAvLyBUaGUgZm9ybWF0IGZvciB0aGlzLmluY2x1ZGUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBmb3JtYXQgZm9yIHRoZVxuICAvLyBpbmNsdWRlIG9wdGlvbiAtIGl0J3MgdGhlIHBhdGhzIHdlIHNob3VsZCBpbmNsdWRlLCBpbiBvcmRlcixcbiAgLy8gc3RvcmVkIGFzIGFycmF5cywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0IHdlIG5lZWQgdG8gaW5jbHVkZSBmb29cbiAgLy8gYmVmb3JlIGluY2x1ZGluZyBmb28uYmFyLiBBbHNvIGl0IHNob3VsZCBkZWR1cGUuXG4gIC8vIEZvciBleGFtcGxlLCBwYXNzaW5nIGFuIGFyZyBvZiBpbmNsdWRlPWZvby5iYXIsZm9vLmJheiBjb3VsZCBsZWFkIHRvXG4gIC8vIHRoaXMuaW5jbHVkZSA9IFtbJ2ZvbyddLCBbJ2ZvbycsICdiYXonXSwgWydmb28nLCAnYmFyJ11dXG4gIHRoaXMuaW5jbHVkZSA9IFtdO1xuICBsZXQga2V5c0ZvckluY2x1ZGUgPSAnJztcblxuICAvLyBJZiB3ZSBoYXZlIGtleXMsIHdlIHByb2JhYmx5IHdhbnQgdG8gZm9yY2Ugc29tZSBpbmNsdWRlcyAobi0xIGxldmVsKVxuICAvLyBTZWUgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wYXJzZS1jb21tdW5pdHkvcGFyc2Utc2VydmVyL2lzc3Vlcy8zMTg1XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdE9wdGlvbnMsICdrZXlzJykpIHtcbiAgICBrZXlzRm9ySW5jbHVkZSA9IHJlc3RPcHRpb25zLmtleXM7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGtleXMsIHdlIHByb2JhYmx5IHdhbnQgdG8gZm9yY2Ugc29tZSBpbmNsdWRlcyAobi0xIGxldmVsKVxuICAvLyBpbiBvcmRlciB0byBleGNsdWRlIHNwZWNpZmljIGtleXMuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdE9wdGlvbnMsICdleGNsdWRlS2V5cycpKSB7XG4gICAga2V5c0ZvckluY2x1ZGUgKz0gJywnICsgcmVzdE9wdGlvbnMuZXhjbHVkZUtleXM7XG4gIH1cblxuICBpZiAoa2V5c0ZvckluY2x1ZGUubGVuZ3RoID4gMCkge1xuICAgIGtleXNGb3JJbmNsdWRlID0ga2V5c0ZvckluY2x1ZGVcbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAuZmlsdGVyKGtleSA9PiB7XG4gICAgICAgIC8vIEF0IGxlYXN0IDIgY29tcG9uZW50c1xuICAgICAgICByZXR1cm4ga2V5LnNwbGl0KCcuJykubGVuZ3RoID4gMTtcbiAgICAgIH0pXG4gICAgICAubWFwKGtleSA9PiB7XG4gICAgICAgIC8vIFNsaWNlIHRoZSBsYXN0IGNvbXBvbmVudCAoYS5iLmMgLT4gYS5iKVxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UnbGwgaW5jbHVkZSBvbmUgbGV2ZWwgdG9vIG11Y2guXG4gICAgICAgIHJldHVybiBrZXkuc2xpY2UoMCwga2V5Lmxhc3RJbmRleE9mKCcuJykpO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcsJyk7XG5cbiAgICAvLyBDb25jYXQgdGhlIHBvc3NpYmx5IHByZXNlbnQgaW5jbHVkZSBzdHJpbmcgd2l0aCB0aGUgb25lIGZyb20gdGhlIGtleXNcbiAgICAvLyBEZWR1cCAvIHNvcnRpbmcgaXMgaGFuZGxlIGluICdpbmNsdWRlJyBjYXNlLlxuICAgIGlmIChrZXlzRm9ySW5jbHVkZS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIXJlc3RPcHRpb25zLmluY2x1ZGUgfHwgcmVzdE9wdGlvbnMuaW5jbHVkZS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXN0T3B0aW9ucy5pbmNsdWRlID0ga2V5c0ZvckluY2x1ZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0T3B0aW9ucy5pbmNsdWRlICs9ICcsJyArIGtleXNGb3JJbmNsdWRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIG9wdGlvbiBpbiByZXN0T3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9uKSB7XG4gICAgICBjYXNlICdrZXlzJzoge1xuICAgICAgICBjb25zdCBrZXlzID0gcmVzdE9wdGlvbnMua2V5c1xuICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgLmZpbHRlcihrZXkgPT4ga2V5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgLmNvbmNhdChBbHdheXNTZWxlY3RlZEtleXMpO1xuICAgICAgICB0aGlzLmtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoa2V5cykpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2V4Y2x1ZGVLZXlzJzoge1xuICAgICAgICBjb25zdCBleGNsdWRlID0gcmVzdE9wdGlvbnMuZXhjbHVkZUtleXNcbiAgICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAgIC5maWx0ZXIoayA9PiBBbHdheXNTZWxlY3RlZEtleXMuaW5kZXhPZihrKSA8IDApO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVLZXlzID0gQXJyYXkuZnJvbShuZXcgU2V0KGV4Y2x1ZGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgIHRoaXMuZG9Db3VudCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5jbHVkZUFsbCc6XG4gICAgICAgIHRoaXMuaW5jbHVkZUFsbCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXhwbGFpbic6XG4gICAgICBjYXNlICdoaW50JzpcbiAgICAgIGNhc2UgJ2Rpc3RpbmN0JzpcbiAgICAgIGNhc2UgJ3BpcGVsaW5lJzpcbiAgICAgIGNhc2UgJ3NraXAnOlxuICAgICAgY2FzZSAnbGltaXQnOlxuICAgICAgY2FzZSAncmVhZFByZWZlcmVuY2UnOlxuICAgICAgICB0aGlzLmZpbmRPcHRpb25zW29wdGlvbl0gPSByZXN0T3B0aW9uc1tvcHRpb25dO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29yZGVyJzpcbiAgICAgICAgdmFyIGZpZWxkcyA9IHJlc3RPcHRpb25zLm9yZGVyLnNwbGl0KCcsJyk7XG4gICAgICAgIHRoaXMuZmluZE9wdGlvbnMuc29ydCA9IGZpZWxkcy5yZWR1Y2UoKHNvcnRNYXAsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgZmllbGQgPSBmaWVsZC50cmltKCk7XG4gICAgICAgICAgaWYgKGZpZWxkID09PSAnJHNjb3JlJyB8fCBmaWVsZCA9PT0gJy0kc2NvcmUnKSB7XG4gICAgICAgICAgICBzb3J0TWFwLnNjb3JlID0geyAkbWV0YTogJ3RleHRTY29yZScgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkWzBdID09ICctJykge1xuICAgICAgICAgICAgc29ydE1hcFtmaWVsZC5zbGljZSgxKV0gPSAtMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydE1hcFtmaWVsZF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ydE1hcDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luY2x1ZGUnOiB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gcmVzdE9wdGlvbnMuaW5jbHVkZS5zcGxpdCgnLCcpO1xuICAgICAgICBpZiAocGF0aHMuaW5jbHVkZXMoJyonKSkge1xuICAgICAgICAgIHRoaXMuaW5jbHVkZUFsbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCB0aGUgZXhpc3RpbmcgaW5jbHVkZXMgKGZyb20ga2V5cylcbiAgICAgICAgY29uc3QgcGF0aFNldCA9IHBhdGhzLnJlZHVjZSgobWVtbywgcGF0aCkgPT4ge1xuICAgICAgICAgIC8vIFNwbGl0IGVhY2ggcGF0aHMgb24gLiAoYS5iLmMgLT4gW2EsYixjXSlcbiAgICAgICAgICAvLyByZWR1Y2UgdG8gY3JlYXRlIGFsbCBwYXRoc1xuICAgICAgICAgIC8vIChbYSxiLGNdIC0+IHthOiB0cnVlLCAnYS5iJzogdHJ1ZSwgJ2EuYi5jJzogdHJ1ZX0pXG4gICAgICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKG1lbW8sIHBhdGgsIGluZGV4LCBwYXJ0cykgPT4ge1xuICAgICAgICAgICAgbWVtb1twYXJ0cy5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4oJy4nKV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwgbWVtbyk7XG4gICAgICAgIH0sIHt9KTtcblxuICAgICAgICB0aGlzLmluY2x1ZGUgPSBPYmplY3Qua2V5cyhwYXRoU2V0KVxuICAgICAgICAgIC5tYXAocyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcy5zcGxpdCgnLicpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoOyAvLyBTb3J0IGJ5IG51bWJlciBvZiBjb21wb25lbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAncmVkaXJlY3RDbGFzc05hbWVGb3JLZXknOlxuICAgICAgICB0aGlzLnJlZGlyZWN0S2V5ID0gcmVzdE9wdGlvbnMucmVkaXJlY3RDbGFzc05hbWVGb3JLZXk7XG4gICAgICAgIHRoaXMucmVkaXJlY3RDbGFzc05hbWUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luY2x1ZGVSZWFkUHJlZmVyZW5jZSc6XG4gICAgICBjYXNlICdzdWJxdWVyeVJlYWRQcmVmZXJlbmNlJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLCAnYmFkIG9wdGlvbjogJyArIG9wdGlvbik7XG4gICAgfVxuICB9XG59XG5cbi8vIEEgY29udmVuaWVudCBtZXRob2QgdG8gcGVyZm9ybSBhbGwgdGhlIHN0ZXBzIG9mIHByb2Nlc3NpbmcgYSBxdWVyeVxuLy8gaW4gb3JkZXIuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc3BvbnNlIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwga2V5c1xuLy8gJ3Jlc3VsdHMnIGFuZCAnY291bnQnLlxuLy8gVE9ETzogY29uc29saWRhdGUgdGhlIHJlcGxhY2VYIGZ1bmN0aW9uc1xuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChleGVjdXRlT3B0aW9ucykge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZFJlc3RXaGVyZSgpO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZGVueVByb3RlY3RlZEZpZWxkcygpO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5jbHVkZUFsbCgpO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRXhjbHVkZUtleXMoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bkZpbmQoZXhlY3V0ZU9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucnVuQ291bnQoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUluY2x1ZGUoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bkFmdGVyRmluZFRyaWdnZXIoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlO1xuICAgIH0pO1xufTtcblxuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBjb25zdCB7IGNvbmZpZywgYXV0aCwgY2xhc3NOYW1lLCByZXN0V2hlcmUsIHJlc3RPcHRpb25zLCBjbGllbnRTREsgfSA9IHRoaXM7XG4gIC8vIGlmIHRoZSBsaW1pdCBpcyBzZXQsIHVzZSBpdFxuICByZXN0T3B0aW9ucy5saW1pdCA9IHJlc3RPcHRpb25zLmxpbWl0IHx8IDEwMDtcbiAgcmVzdE9wdGlvbnMub3JkZXIgPSAnb2JqZWN0SWQnO1xuICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcblxuICByZXR1cm4gY29udGludWVXaGlsZShcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gIWZpbmlzaGVkO1xuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2FmZSBoZXJlIHRvIHVzZSBfVW5zYWZlUmVzdFF1ZXJ5IGJlY2F1c2UgdGhlIHNlY3VyaXR5IHdhcyBhbHJlYWR5XG4gICAgICAvLyBjaGVja2VkIGR1cmluZyBcImF3YWl0IFJlc3RRdWVyeSgpXCJcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IF9VbnNhZmVSZXN0UXVlcnkoXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZXN0V2hlcmUsXG4gICAgICAgIHJlc3RPcHRpb25zLFxuICAgICAgICBjbGllbnRTREssXG4gICAgICAgIHRoaXMucnVuQWZ0ZXJGaW5kLFxuICAgICAgICB0aGlzLmNvbnRleHRcbiAgICAgICk7XG4gICAgICBjb25zdCB7IHJlc3VsdHMgfSA9IGF3YWl0IHF1ZXJ5LmV4ZWN1dGUoKTtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICBmaW5pc2hlZCA9IHJlc3VsdHMubGVuZ3RoIDwgcmVzdE9wdGlvbnMubGltaXQ7XG4gICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgIHJlc3RXaGVyZS5vYmplY3RJZCA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3RXaGVyZS5vYmplY3RJZCwge1xuICAgICAgICAgICRndDogcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdLm9iamVjdElkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59O1xuXG5fVW5zYWZlUmVzdFF1ZXJ5LnByb3RvdHlwZS5idWlsZFJlc3RXaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VXNlckFuZFJvbGVBQ0woKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5KCk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUNsaWVudENsYXNzQ3JlYXRpb24oKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTZWxlY3QoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VEb250U2VsZWN0KCk7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlSW5RdWVyeSgpO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZU5vdEluUXVlcnkoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VFcXVhbGl0eSgpO1xuICAgIH0pO1xufTtcblxuLy8gVXNlcyB0aGUgQXV0aCBvYmplY3QgdG8gZ2V0IHRoZSBsaXN0IG9mIHJvbGVzLCBhZGRzIHRoZSB1c2VyIGlkXG5fVW5zYWZlUmVzdFF1ZXJ5LnByb3RvdHlwZS5nZXRVc2VyQW5kUm9sZUFDTCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXV0aC5pc01hc3Rlcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHRoaXMuZmluZE9wdGlvbnMuYWNsID0gWycqJ107XG5cbiAgaWYgKHRoaXMuYXV0aC51c2VyKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aC5nZXRVc2VyUm9sZXMoKS50aGVuKHJvbGVzID0+IHtcbiAgICAgIHRoaXMuZmluZE9wdGlvbnMuYWNsID0gdGhpcy5maW5kT3B0aW9ucy5hY2wuY29uY2F0KHJvbGVzLCBbdGhpcy5hdXRoLnVzZXIuaWRdKTtcbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn07XG5cbi8vIENoYW5nZXMgdGhlIGNsYXNzTmFtZSBpZiByZWRpcmVjdENsYXNzTmFtZUZvcktleSBpcyBzZXQuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZS5cbl9VbnNhZmVSZXN0UXVlcnkucHJvdG90eXBlLnJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucmVkaXJlY3RLZXkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgY2xhc3MgbmFtZSBiYXNlZCBvbiB0aGUgc2NoZW1hXG4gIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhYmFzZVxuICAgIC5yZWRpcmVjdENsYXNzTmFtZUZvcktleSh0aGlzLmNsYXNzTmFtZSwgdGhpcy5yZWRpcmVjdEtleSlcbiAgICAudGhlbihuZXdDbGFzc05hbWUgPT4ge1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBuZXdDbGFzc05hbWU7XG4gICAgICB0aGlzLnJlZGlyZWN0Q2xhc3NOYW1lID0gbmV3Q2xhc3NOYW1lO1xuICAgIH0pO1xufTtcblxuLy8gVmFsaWRhdGVzIHRoaXMgb3BlcmF0aW9uIGFnYWluc3QgdGhlIGFsbG93Q2xpZW50Q2xhc3NDcmVhdGlvbiBjb25maWcuXG5fVW5zYWZlUmVzdFF1ZXJ5LnByb3RvdHlwZS52YWxpZGF0ZUNsaWVudENsYXNzQ3JlYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChcbiAgICB0aGlzLmNvbmZpZy5hbGxvd0NsaWVudENsYXNzQ3JlYXRpb24gPT09IGZhbHNlICYmXG4gICAgIXRoaXMuYXV0aC5pc01hc3RlciAmJlxuICAgIFNjaGVtYUNvbnRyb2xsZXIuc3lzdGVtQ2xhc3Nlcy5pbmRleE9mKHRoaXMuY2xhc3NOYW1lKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGFiYXNlXG4gICAgICAubG9hZFNjaGVtYSgpXG4gICAgICAudGhlbihzY2hlbWFDb250cm9sbGVyID0+IHNjaGVtYUNvbnRyb2xsZXIuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpKVxuICAgICAgLnRoZW4oaGFzQ2xhc3MgPT4ge1xuICAgICAgICBpZiAoaGFzQ2xhc3MgIT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgICAgICBQYXJzZS5FcnJvci5PUEVSQVRJT05fRk9SQklEREVOLFxuICAgICAgICAgICAgJ1RoaXMgdXNlciBpcyBub3QgYWxsb3dlZCB0byBhY2Nlc3MgJyArICdub24tZXhpc3RlbnQgY2xhc3M6ICcgKyB0aGlzLmNsYXNzTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtSW5RdWVyeShpblF1ZXJ5T2JqZWN0LCBjbGFzc05hbWUsIHJlc3VsdHMpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgIF9fdHlwZTogJ1BvaW50ZXInLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICBvYmplY3RJZDogcmVzdWx0Lm9iamVjdElkLFxuICAgIH0pO1xuICB9XG4gIGRlbGV0ZSBpblF1ZXJ5T2JqZWN0WyckaW5RdWVyeSddO1xuICBpZiAoQXJyYXkuaXNBcnJheShpblF1ZXJ5T2JqZWN0WyckaW4nXSkpIHtcbiAgICBpblF1ZXJ5T2JqZWN0WyckaW4nXSA9IGluUXVlcnlPYmplY3RbJyRpbiddLmNvbmNhdCh2YWx1ZXMpO1xuICB9IGVsc2Uge1xuICAgIGluUXVlcnlPYmplY3RbJyRpbiddID0gdmFsdWVzO1xuICB9XG59XG5cbi8vIFJlcGxhY2VzIGEgJGluUXVlcnkgY2xhdXNlIGJ5IHJ1bm5pbmcgdGhlIHN1YnF1ZXJ5LCBpZiB0aGVyZSBpcyBhblxuLy8gJGluUXVlcnkgY2xhdXNlLlxuLy8gVGhlICRpblF1ZXJ5IGNsYXVzZSB0dXJucyBpbnRvIGFuICRpbiB3aXRoIHZhbHVlcyB0aGF0IGFyZSBqdXN0XG4vLyBwb2ludGVycyB0byB0aGUgb2JqZWN0cyByZXR1cm5lZCBpbiB0aGUgc3VicXVlcnkuXG5fVW5zYWZlUmVzdFF1ZXJ5LnByb3RvdHlwZS5yZXBsYWNlSW5RdWVyeSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdmFyIGluUXVlcnlPYmplY3QgPSBmaW5kT2JqZWN0V2l0aEtleSh0aGlzLnJlc3RXaGVyZSwgJyRpblF1ZXJ5Jyk7XG4gIGlmICghaW5RdWVyeU9iamVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSBpblF1ZXJ5IHZhbHVlIG11c3QgaGF2ZSBwcmVjaXNlbHkgdHdvIGtleXMgLSB3aGVyZSBhbmQgY2xhc3NOYW1lXG4gIHZhciBpblF1ZXJ5VmFsdWUgPSBpblF1ZXJ5T2JqZWN0WyckaW5RdWVyeSddO1xuICBpZiAoIWluUXVlcnlWYWx1ZS53aGVyZSB8fCAhaW5RdWVyeVZhbHVlLmNsYXNzTmFtZSkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5JTlZBTElEX1FVRVJZLCAnaW1wcm9wZXIgdXNhZ2Ugb2YgJGluUXVlcnknKTtcbiAgfVxuXG4gIGNvbnN0IGFkZGl0aW9uYWxPcHRpb25zID0ge1xuICAgIHJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5OiBpblF1ZXJ5VmFsdWUucmVkaXJlY3RDbGFzc05hbWVGb3JLZXksXG4gIH07XG5cbiAgaWYgKHRoaXMucmVzdE9wdGlvbnMuc3VicXVlcnlSZWFkUHJlZmVyZW5jZSkge1xuICAgIGFkZGl0aW9uYWxPcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gdGhpcy5yZXN0T3B0aW9ucy5zdWJxdWVyeVJlYWRQcmVmZXJlbmNlO1xuICAgIGFkZGl0aW9uYWxPcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2UgPSB0aGlzLnJlc3RPcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2U7XG4gIH0gZWxzZSBpZiAodGhpcy5yZXN0T3B0aW9ucy5yZWFkUHJlZmVyZW5jZSkge1xuICAgIGFkZGl0aW9uYWxPcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gdGhpcy5yZXN0T3B0aW9ucy5yZWFkUHJlZmVyZW5jZTtcbiAgfVxuXG4gIGNvbnN0IHN1YnF1ZXJ5ID0gYXdhaXQgUmVzdFF1ZXJ5KHtcbiAgICBtZXRob2Q6IFJlc3RRdWVyeS5NZXRob2QuZmluZCxcbiAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICBjbGFzc05hbWU6IGluUXVlcnlWYWx1ZS5jbGFzc05hbWUsXG4gICAgcmVzdFdoZXJlOiBpblF1ZXJ5VmFsdWUud2hlcmUsXG4gICAgcmVzdE9wdGlvbnM6IGFkZGl0aW9uYWxPcHRpb25zLFxuICB9KTtcbiAgcmV0dXJuIHN1YnF1ZXJ5LmV4ZWN1dGUoKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICB0cmFuc2Zvcm1JblF1ZXJ5KGluUXVlcnlPYmplY3QsIHN1YnF1ZXJ5LmNsYXNzTmFtZSwgcmVzcG9uc2UucmVzdWx0cyk7XG4gICAgLy8gUmVjdXJzZSB0byByZXBlYXRcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlSW5RdWVyeSgpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vdEluUXVlcnkobm90SW5RdWVyeU9iamVjdCwgY2xhc3NOYW1lLCByZXN1bHRzKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgZm9yICh2YXIgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICB2YWx1ZXMucHVzaCh7XG4gICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgb2JqZWN0SWQ6IHJlc3VsdC5vYmplY3RJZCxcbiAgICB9KTtcbiAgfVxuICBkZWxldGUgbm90SW5RdWVyeU9iamVjdFsnJG5vdEluUXVlcnknXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm90SW5RdWVyeU9iamVjdFsnJG5pbiddKSkge1xuICAgIG5vdEluUXVlcnlPYmplY3RbJyRuaW4nXSA9IG5vdEluUXVlcnlPYmplY3RbJyRuaW4nXS5jb25jYXQodmFsdWVzKTtcbiAgfSBlbHNlIHtcbiAgICBub3RJblF1ZXJ5T2JqZWN0WyckbmluJ10gPSB2YWx1ZXM7XG4gIH1cbn1cblxuLy8gUmVwbGFjZXMgYSAkbm90SW5RdWVyeSBjbGF1c2UgYnkgcnVubmluZyB0aGUgc3VicXVlcnksIGlmIHRoZXJlIGlzIGFuXG4vLyAkbm90SW5RdWVyeSBjbGF1c2UuXG4vLyBUaGUgJG5vdEluUXVlcnkgY2xhdXNlIHR1cm5zIGludG8gYSAkbmluIHdpdGggdmFsdWVzIHRoYXQgYXJlIGp1c3Rcbi8vIHBvaW50ZXJzIHRvIHRoZSBvYmplY3RzIHJldHVybmVkIGluIHRoZSBzdWJxdWVyeS5cbl9VbnNhZmVSZXN0UXVlcnkucHJvdG90eXBlLnJlcGxhY2VOb3RJblF1ZXJ5ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB2YXIgbm90SW5RdWVyeU9iamVjdCA9IGZpbmRPYmplY3RXaXRoS2V5KHRoaXMucmVzdFdoZXJlLCAnJG5vdEluUXVlcnknKTtcbiAgaWYgKCFub3RJblF1ZXJ5T2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIG5vdEluUXVlcnkgdmFsdWUgbXVzdCBoYXZlIHByZWNpc2VseSB0d28ga2V5cyAtIHdoZXJlIGFuZCBjbGFzc05hbWVcbiAgdmFyIG5vdEluUXVlcnlWYWx1ZSA9IG5vdEluUXVlcnlPYmplY3RbJyRub3RJblF1ZXJ5J107XG4gIGlmICghbm90SW5RdWVyeVZhbHVlLndoZXJlIHx8ICFub3RJblF1ZXJ5VmFsdWUuY2xhc3NOYW1lKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLklOVkFMSURfUVVFUlksICdpbXByb3BlciB1c2FnZSBvZiAkbm90SW5RdWVyeScpO1xuICB9XG5cbiAgY29uc3QgYWRkaXRpb25hbE9wdGlvbnMgPSB7XG4gICAgcmVkaXJlY3RDbGFzc05hbWVGb3JLZXk6IG5vdEluUXVlcnlWYWx1ZS5yZWRpcmVjdENsYXNzTmFtZUZvcktleSxcbiAgfTtcblxuICBpZiAodGhpcy5yZXN0T3B0aW9ucy5zdWJxdWVyeVJlYWRQcmVmZXJlbmNlKSB7XG4gICAgYWRkaXRpb25hbE9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSB0aGlzLnJlc3RPcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2U7XG4gICAgYWRkaXRpb25hbE9wdGlvbnMuc3VicXVlcnlSZWFkUHJlZmVyZW5jZSA9IHRoaXMucmVzdE9wdGlvbnMuc3VicXVlcnlSZWFkUHJlZmVyZW5jZTtcbiAgfSBlbHNlIGlmICh0aGlzLnJlc3RPcHRpb25zLnJlYWRQcmVmZXJlbmNlKSB7XG4gICAgYWRkaXRpb25hbE9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSB0aGlzLnJlc3RPcHRpb25zLnJlYWRQcmVmZXJlbmNlO1xuICB9XG5cbiAgY29uc3Qgc3VicXVlcnkgPSBhd2FpdCBSZXN0UXVlcnkoe1xuICAgIG1ldGhvZDogUmVzdFF1ZXJ5Lk1ldGhvZC5maW5kLFxuICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgYXV0aDogdGhpcy5hdXRoLFxuICAgIGNsYXNzTmFtZTogbm90SW5RdWVyeVZhbHVlLmNsYXNzTmFtZSxcbiAgICByZXN0V2hlcmU6IG5vdEluUXVlcnlWYWx1ZS53aGVyZSxcbiAgICByZXN0T3B0aW9uczogYWRkaXRpb25hbE9wdGlvbnMsXG4gIH0pO1xuXG4gIHJldHVybiBzdWJxdWVyeS5leGVjdXRlKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgdHJhbnNmb3JtTm90SW5RdWVyeShub3RJblF1ZXJ5T2JqZWN0LCBzdWJxdWVyeS5jbGFzc05hbWUsIHJlc3BvbnNlLnJlc3VsdHMpO1xuICAgIC8vIFJlY3Vyc2UgdG8gcmVwZWF0XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZU5vdEluUXVlcnkoKTtcbiAgfSk7XG59O1xuXG4vLyBVc2VkIHRvIGdldCB0aGUgZGVlcGVzdCBvYmplY3QgZnJvbSBqc29uIHVzaW5nIGRvdCBub3RhdGlvbi5cbmNvbnN0IGdldERlZXBlc3RPYmplY3RGcm9tS2V5ID0gKGpzb24sIGtleSwgaWR4LCBzcmMpID0+IHtcbiAgaWYgKGtleSBpbiBqc29uKSB7XG4gICAgcmV0dXJuIGpzb25ba2V5XTtcbiAgfVxuICBzcmMuc3BsaWNlKDEpOyAvLyBFeGl0IEVhcmx5XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1TZWxlY3QgPSAoc2VsZWN0T2JqZWN0LCBrZXksIG9iamVjdHMpID0+IHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciByZXN1bHQgb2Ygb2JqZWN0cykge1xuICAgIHZhbHVlcy5wdXNoKGtleS5zcGxpdCgnLicpLnJlZHVjZShnZXREZWVwZXN0T2JqZWN0RnJvbUtleSwgcmVzdWx0KSk7XG4gIH1cbiAgZGVsZXRlIHNlbGVjdE9iamVjdFsnJHNlbGVjdCddO1xuICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RPYmplY3RbJyRpbiddKSkge1xuICAgIHNlbGVjdE9iamVjdFsnJGluJ10gPSBzZWxlY3RPYmplY3RbJyRpbiddLmNvbmNhdCh2YWx1ZXMpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdE9iamVjdFsnJGluJ10gPSB2YWx1ZXM7XG4gIH1cbn07XG5cbi8vIFJlcGxhY2VzIGEgJHNlbGVjdCBjbGF1c2UgYnkgcnVubmluZyB0aGUgc3VicXVlcnksIGlmIHRoZXJlIGlzIGFcbi8vICRzZWxlY3QgY2xhdXNlLlxuLy8gVGhlICRzZWxlY3QgY2xhdXNlIHR1cm5zIGludG8gYW4gJGluIHdpdGggdmFsdWVzIHNlbGVjdGVkIG91dCBvZlxuLy8gdGhlIHN1YnF1ZXJ5LlxuLy8gUmV0dXJucyBhIHBvc3NpYmxlLXByb21pc2UuXG5fVW5zYWZlUmVzdFF1ZXJ5LnByb3RvdHlwZS5yZXBsYWNlU2VsZWN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZWN0T2JqZWN0ID0gZmluZE9iamVjdFdpdGhLZXkodGhpcy5yZXN0V2hlcmUsICckc2VsZWN0Jyk7XG4gIGlmICghc2VsZWN0T2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIHNlbGVjdCB2YWx1ZSBtdXN0IGhhdmUgcHJlY2lzZWx5IHR3byBrZXlzIC0gcXVlcnkgYW5kIGtleVxuICB2YXIgc2VsZWN0VmFsdWUgPSBzZWxlY3RPYmplY3RbJyRzZWxlY3QnXTtcbiAgLy8gaU9TIFNESyBkb24ndCBzZW5kIHdoZXJlIGlmIG5vdCBzZXQsIGxldCBpdCBwYXNzXG4gIGlmIChcbiAgICAhc2VsZWN0VmFsdWUucXVlcnkgfHxcbiAgICAhc2VsZWN0VmFsdWUua2V5IHx8XG4gICAgdHlwZW9mIHNlbGVjdFZhbHVlLnF1ZXJ5ICE9PSAnb2JqZWN0JyB8fFxuICAgICFzZWxlY3RWYWx1ZS5xdWVyeS5jbGFzc05hbWUgfHxcbiAgICBPYmplY3Qua2V5cyhzZWxlY3RWYWx1ZSkubGVuZ3RoICE9PSAyXG4gICkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5JTlZBTElEX1FVRVJZLCAnaW1wcm9wZXIgdXNhZ2Ugb2YgJHNlbGVjdCcpO1xuICB9XG5cbiAgY29uc3QgYWRkaXRpb25hbE9wdGlvbnMgPSB7XG4gICAgcmVkaXJlY3RDbGFzc05hbWVGb3JLZXk6IHNlbGVjdFZhbHVlLnF1ZXJ5LnJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5LFxuICB9O1xuXG4gIGlmICh0aGlzLnJlc3RPcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2UpIHtcbiAgICBhZGRpdGlvbmFsT3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHRoaXMucmVzdE9wdGlvbnMuc3VicXVlcnlSZWFkUHJlZmVyZW5jZTtcbiAgICBhZGRpdGlvbmFsT3B0aW9ucy5zdWJxdWVyeVJlYWRQcmVmZXJlbmNlID0gdGhpcy5yZXN0T3B0aW9ucy5zdWJxdWVyeVJlYWRQcmVmZXJlbmNlO1xuICB9IGVsc2UgaWYgKHRoaXMucmVzdE9wdGlvbnMucmVhZFByZWZlcmVuY2UpIHtcbiAgICBhZGRpdGlvbmFsT3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHRoaXMucmVzdE9wdGlvbnMucmVhZFByZWZlcmVuY2U7XG4gIH1cblxuICBjb25zdCBzdWJxdWVyeSA9IGF3YWl0IFJlc3RRdWVyeSh7XG4gICAgbWV0aG9kOiBSZXN0UXVlcnkuTWV0aG9kLmZpbmQsXG4gICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICBhdXRoOiB0aGlzLmF1dGgsXG4gICAgY2xhc3NOYW1lOiBzZWxlY3RWYWx1ZS5xdWVyeS5jbGFzc05hbWUsXG4gICAgcmVzdFdoZXJlOiBzZWxlY3RWYWx1ZS5xdWVyeS53aGVyZSxcbiAgICByZXN0T3B0aW9uczogYWRkaXRpb25hbE9wdGlvbnMsXG4gIH0pO1xuXG4gIHJldHVybiBzdWJxdWVyeS5leGVjdXRlKCkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgdHJhbnNmb3JtU2VsZWN0KHNlbGVjdE9iamVjdCwgc2VsZWN0VmFsdWUua2V5LCByZXNwb25zZS5yZXN1bHRzKTtcbiAgICAvLyBLZWVwIHJlcGxhY2luZyAkc2VsZWN0IGNsYXVzZXNcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlU2VsZWN0KCk7XG4gIH0pO1xufTtcblxuY29uc3QgdHJhbnNmb3JtRG9udFNlbGVjdCA9IChkb250U2VsZWN0T2JqZWN0LCBrZXksIG9iamVjdHMpID0+IHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciByZXN1bHQgb2Ygb2JqZWN0cykge1xuICAgIHZhbHVlcy5wdXNoKGtleS5zcGxpdCgnLicpLnJlZHVjZShnZXREZWVwZXN0T2JqZWN0RnJvbUtleSwgcmVzdWx0KSk7XG4gIH1cbiAgZGVsZXRlIGRvbnRTZWxlY3RPYmplY3RbJyRkb250U2VsZWN0J107XG4gIGlmIChBcnJheS5pc0FycmF5KGRvbnRTZWxlY3RPYmplY3RbJyRuaW4nXSkpIHtcbiAgICBkb250U2VsZWN0T2JqZWN0WyckbmluJ10gPSBkb250U2VsZWN0T2JqZWN0WyckbmluJ10uY29uY2F0KHZhbHVlcyk7XG4gIH0gZWxzZSB7XG4gICAgZG9udFNlbGVjdE9iamVjdFsnJG5pbiddID0gdmFsdWVzO1xuICB9XG59O1xuXG4vLyBSZXBsYWNlcyBhICRkb250U2VsZWN0IGNsYXVzZSBieSBydW5uaW5nIHRoZSBzdWJxdWVyeSwgaWYgdGhlcmUgaXMgYVxuLy8gJGRvbnRTZWxlY3QgY2xhdXNlLlxuLy8gVGhlICRkb250U2VsZWN0IGNsYXVzZSB0dXJucyBpbnRvIGFuICRuaW4gd2l0aCB2YWx1ZXMgc2VsZWN0ZWQgb3V0IG9mXG4vLyB0aGUgc3VicXVlcnkuXG4vLyBSZXR1cm5zIGEgcG9zc2libGUtcHJvbWlzZS5cbl9VbnNhZmVSZXN0UXVlcnkucHJvdG90eXBlLnJlcGxhY2VEb250U2VsZWN0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB2YXIgZG9udFNlbGVjdE9iamVjdCA9IGZpbmRPYmplY3RXaXRoS2V5KHRoaXMucmVzdFdoZXJlLCAnJGRvbnRTZWxlY3QnKTtcbiAgaWYgKCFkb250U2VsZWN0T2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIGRvbnRTZWxlY3QgdmFsdWUgbXVzdCBoYXZlIHByZWNpc2VseSB0d28ga2V5cyAtIHF1ZXJ5IGFuZCBrZXlcbiAgdmFyIGRvbnRTZWxlY3RWYWx1ZSA9IGRvbnRTZWxlY3RPYmplY3RbJyRkb250U2VsZWN0J107XG4gIGlmIChcbiAgICAhZG9udFNlbGVjdFZhbHVlLnF1ZXJ5IHx8XG4gICAgIWRvbnRTZWxlY3RWYWx1ZS5rZXkgfHxcbiAgICB0eXBlb2YgZG9udFNlbGVjdFZhbHVlLnF1ZXJ5ICE9PSAnb2JqZWN0JyB8fFxuICAgICFkb250U2VsZWN0VmFsdWUucXVlcnkuY2xhc3NOYW1lIHx8XG4gICAgT2JqZWN0LmtleXMoZG9udFNlbGVjdFZhbHVlKS5sZW5ndGggIT09IDJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLklOVkFMSURfUVVFUlksICdpbXByb3BlciB1c2FnZSBvZiAkZG9udFNlbGVjdCcpO1xuICB9XG4gIGNvbnN0IGFkZGl0aW9uYWxPcHRpb25zID0ge1xuICAgIHJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5OiBkb250U2VsZWN0VmFsdWUucXVlcnkucmVkaXJlY3RDbGFzc05hbWVGb3JLZXksXG4gIH07XG5cbiAgaWYgKHRoaXMucmVzdE9wdGlvbnMuc3VicXVlcnlSZWFkUHJlZmVyZW5jZSkge1xuICAgIGFkZGl0aW9uYWxPcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gdGhpcy5yZXN0T3B0aW9ucy5zdWJxdWVyeVJlYWRQcmVmZXJlbmNlO1xuICAgIGFkZGl0aW9uYWxPcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2UgPSB0aGlzLnJlc3RPcHRpb25zLnN1YnF1ZXJ5UmVhZFByZWZlcmVuY2U7XG4gIH0gZWxzZSBpZiAodGhpcy5yZXN0T3B0aW9ucy5yZWFkUHJlZmVyZW5jZSkge1xuICAgIGFkZGl0aW9uYWxPcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gdGhpcy5yZXN0T3B0aW9ucy5yZWFkUHJlZmVyZW5jZTtcbiAgfVxuXG4gIGNvbnN0IHN1YnF1ZXJ5ID0gYXdhaXQgUmVzdFF1ZXJ5KHtcbiAgICBtZXRob2Q6IFJlc3RRdWVyeS5NZXRob2QuZmluZCxcbiAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgIGF1dGg6IHRoaXMuYXV0aCxcbiAgICBjbGFzc05hbWU6IGRvbnRTZWxlY3RWYWx1ZS5xdWVyeS5jbGFzc05hbWUsXG4gICAgcmVzdFdoZXJlOiBkb250U2VsZWN0VmFsdWUucXVlcnkud2hlcmUsXG4gICAgcmVzdE9wdGlvbnM6IGFkZGl0aW9uYWxPcHRpb25zLFxuICB9KTtcblxuICByZXR1cm4gc3VicXVlcnkuZXhlY3V0ZSgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIHRyYW5zZm9ybURvbnRTZWxlY3QoZG9udFNlbGVjdE9iamVjdCwgZG9udFNlbGVjdFZhbHVlLmtleSwgcmVzcG9uc2UucmVzdWx0cyk7XG4gICAgLy8gS2VlcCByZXBsYWNpbmcgJGRvbnRTZWxlY3QgY2xhdXNlc1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VEb250U2VsZWN0KCk7XG4gIH0pO1xufTtcblxuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUuY2xlYW5SZXN1bHRBdXRoRGF0YSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgZGVsZXRlIHJlc3VsdC5wYXNzd29yZDtcbiAgaWYgKHJlc3VsdC5hdXRoRGF0YSkge1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdC5hdXRoRGF0YSkuZm9yRWFjaChwcm92aWRlciA9PiB7XG4gICAgICBpZiAocmVzdWx0LmF1dGhEYXRhW3Byb3ZpZGVyXSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcmVzdWx0LmF1dGhEYXRhW3Byb3ZpZGVyXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhyZXN1bHQuYXV0aERhdGEpLmxlbmd0aCA9PSAwKSB7XG4gICAgICBkZWxldGUgcmVzdWx0LmF1dGhEYXRhO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgcmVwbGFjZUVxdWFsaXR5Q29uc3RyYWludCA9IGNvbnN0cmFpbnQgPT4ge1xuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gIH1cbiAgY29uc3QgZXF1YWxUb09iamVjdCA9IHt9O1xuICBsZXQgaGFzRGlyZWN0Q29uc3RyYWludCA9IGZhbHNlO1xuICBsZXQgaGFzT3BlcmF0b3JDb25zdHJhaW50ID0gZmFsc2U7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbnN0cmFpbnQpIHtcbiAgICBpZiAoa2V5LmluZGV4T2YoJyQnKSAhPT0gMCkge1xuICAgICAgaGFzRGlyZWN0Q29uc3RyYWludCA9IHRydWU7XG4gICAgICBlcXVhbFRvT2JqZWN0W2tleV0gPSBjb25zdHJhaW50W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc09wZXJhdG9yQ29uc3RyYWludCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChoYXNEaXJlY3RDb25zdHJhaW50ICYmIGhhc09wZXJhdG9yQ29uc3RyYWludCkge1xuICAgIGNvbnN0cmFpbnRbJyRlcSddID0gZXF1YWxUb09iamVjdDtcbiAgICBPYmplY3Qua2V5cyhlcXVhbFRvT2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBkZWxldGUgY29uc3RyYWludFtrZXldO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50O1xufTtcblxuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUucmVwbGFjZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMucmVzdFdoZXJlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnJlc3RXaGVyZSkge1xuICAgIHRoaXMucmVzdFdoZXJlW2tleV0gPSByZXBsYWNlRXF1YWxpdHlDb25zdHJhaW50KHRoaXMucmVzdFdoZXJlW2tleV0pO1xuICB9XG59O1xuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3Igd2hldGhlciBpdCB3YXMgc3VjY2Vzc2Z1bC5cbi8vIFBvcHVsYXRlcyB0aGlzLnJlc3BvbnNlIHdpdGggYW4gb2JqZWN0IHRoYXQgb25seSBoYXMgJ3Jlc3VsdHMnLlxuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUucnVuRmluZCA9IGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgaWYgKHRoaXMuZmluZE9wdGlvbnMubGltaXQgPT09IDApIHtcbiAgICB0aGlzLnJlc3BvbnNlID0geyByZXN1bHRzOiBbXSB9O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBjb25zdCBmaW5kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmluZE9wdGlvbnMpO1xuICBpZiAodGhpcy5rZXlzKSB7XG4gICAgZmluZE9wdGlvbnMua2V5cyA9IHRoaXMua2V5cy5tYXAoa2V5ID0+IHtcbiAgICAgIHJldHVybiBrZXkuc3BsaXQoJy4nKVswXTtcbiAgICB9KTtcbiAgfVxuICBpZiAob3B0aW9ucy5vcCkge1xuICAgIGZpbmRPcHRpb25zLm9wID0gb3B0aW9ucy5vcDtcbiAgfVxuICByZXR1cm4gdGhpcy5jb25maWcuZGF0YWJhc2VcbiAgICAuZmluZCh0aGlzLmNsYXNzTmFtZSwgdGhpcy5yZXN0V2hlcmUsIGZpbmRPcHRpb25zLCB0aGlzLmF1dGgpXG4gICAgLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICBpZiAodGhpcy5jbGFzc05hbWUgPT09ICdfVXNlcicgJiYgIWZpbmRPcHRpb25zLmV4cGxhaW4pIHtcbiAgICAgICAgZm9yICh2YXIgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICB0aGlzLmNsZWFuUmVzdWx0QXV0aERhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbmZpZy5maWxlc0NvbnRyb2xsZXIuZXhwYW5kRmlsZXNJbk9iamVjdCh0aGlzLmNvbmZpZywgcmVzdWx0cyk7XG5cbiAgICAgIGlmICh0aGlzLnJlZGlyZWN0Q2xhc3NOYW1lKSB7XG4gICAgICAgIGZvciAodmFyIHIgb2YgcmVzdWx0cykge1xuICAgICAgICAgIHIuY2xhc3NOYW1lID0gdGhpcy5yZWRpcmVjdENsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXNwb25zZSA9IHsgcmVzdWx0czogcmVzdWx0cyB9O1xuICAgIH0pO1xufTtcblxuLy8gUmV0dXJucyBhIHByb21pc2UgZm9yIHdoZXRoZXIgaXQgd2FzIHN1Y2Nlc3NmdWwuXG4vLyBQb3B1bGF0ZXMgdGhpcy5yZXNwb25zZS5jb3VudCB3aXRoIHRoZSBjb3VudFxuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUucnVuQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5kb0NvdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZmluZE9wdGlvbnMuY291bnQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5maW5kT3B0aW9ucy5za2lwO1xuICBkZWxldGUgdGhpcy5maW5kT3B0aW9ucy5saW1pdDtcbiAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGFiYXNlLmZpbmQodGhpcy5jbGFzc05hbWUsIHRoaXMucmVzdFdoZXJlLCB0aGlzLmZpbmRPcHRpb25zKS50aGVuKGMgPT4ge1xuICAgIHRoaXMucmVzcG9uc2UuY291bnQgPSBjO1xuICB9KTtcbn07XG5cbl9VbnNhZmVSZXN0UXVlcnkucHJvdG90eXBlLmRlbnlQcm90ZWN0ZWRGaWVsZHMgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmF1dGguaXNNYXN0ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2NoZW1hQ29udHJvbGxlciA9IGF3YWl0IHRoaXMuY29uZmlnLmRhdGFiYXNlLmxvYWRTY2hlbWEoKTtcbiAgY29uc3QgcHJvdGVjdGVkRmllbGRzID1cbiAgICB0aGlzLmNvbmZpZy5kYXRhYmFzZS5hZGRQcm90ZWN0ZWRGaWVsZHMoXG4gICAgICBzY2hlbWFDb250cm9sbGVyLFxuICAgICAgdGhpcy5jbGFzc05hbWUsXG4gICAgICB0aGlzLnJlc3RXaGVyZSxcbiAgICAgIHRoaXMuZmluZE9wdGlvbnMuYWNsLFxuICAgICAgdGhpcy5hdXRoLFxuICAgICAgdGhpcy5maW5kT3B0aW9uc1xuICAgICkgfHwgW107XG4gIGZvciAoY29uc3Qga2V5IG9mIHByb3RlY3RlZEZpZWxkcykge1xuICAgIGlmICh0aGlzLnJlc3RXaGVyZVtrZXldKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoXG4gICAgICAgIFBhcnNlLkVycm9yLk9QRVJBVElPTl9GT1JCSURERU4sXG4gICAgICAgIGBUaGlzIHVzZXIgaXMgbm90IGFsbG93ZWQgdG8gcXVlcnkgJHtrZXl9IG9uIGNsYXNzICR7dGhpcy5jbGFzc05hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEF1Z21lbnRzIHRoaXMucmVzcG9uc2Ugd2l0aCBhbGwgcG9pbnRlcnMgb24gYW4gb2JqZWN0XG5fVW5zYWZlUmVzdFF1ZXJ5LnByb3RvdHlwZS5oYW5kbGVJbmNsdWRlQWxsID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaW5jbHVkZUFsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5jb25maWcuZGF0YWJhc2VcbiAgICAubG9hZFNjaGVtYSgpXG4gICAgLnRoZW4oc2NoZW1hQ29udHJvbGxlciA9PiBzY2hlbWFDb250cm9sbGVyLmdldE9uZVNjaGVtYSh0aGlzLmNsYXNzTmFtZSkpXG4gICAgLnRoZW4oc2NoZW1hID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGVGaWVsZHMgPSBbXTtcbiAgICAgIGNvbnN0IGtleUZpZWxkcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBzY2hlbWEuZmllbGRzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoc2NoZW1hLmZpZWxkc1tmaWVsZF0udHlwZSAmJiBzY2hlbWEuZmllbGRzW2ZpZWxkXS50eXBlID09PSAnUG9pbnRlcicpIHx8XG4gICAgICAgICAgKHNjaGVtYS5maWVsZHNbZmllbGRdLnR5cGUgJiYgc2NoZW1hLmZpZWxkc1tmaWVsZF0udHlwZSA9PT0gJ0FycmF5JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW5jbHVkZUZpZWxkcy5wdXNoKFtmaWVsZF0pO1xuICAgICAgICAgIGtleUZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQWRkIGZpZWxkcyB0byBpbmNsdWRlLCBrZXlzLCByZW1vdmUgZHVwc1xuICAgICAgdGhpcy5pbmNsdWRlID0gWy4uLm5ldyBTZXQoWy4uLnRoaXMuaW5jbHVkZSwgLi4uaW5jbHVkZUZpZWxkc10pXTtcbiAgICAgIC8vIGlmIHRoaXMua2V5cyBub3Qgc2V0LCB0aGVuIGFsbCBrZXlzIGFyZSBhbHJlYWR5IGluY2x1ZGVkXG4gICAgICBpZiAodGhpcy5rZXlzKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFsuLi5uZXcgU2V0KFsuLi50aGlzLmtleXMsIC4uLmtleUZpZWxkc10pXTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIFVwZGF0ZXMgcHJvcGVydHkgYHRoaXMua2V5c2AgdG8gY29udGFpbiBhbGwga2V5cyBidXQgdGhlIG9uZXMgdW5zZWxlY3RlZC5cbl9VbnNhZmVSZXN0UXVlcnkucHJvdG90eXBlLmhhbmRsZUV4Y2x1ZGVLZXlzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZXhjbHVkZUtleXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRoaXMua2V5cykge1xuICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cy5maWx0ZXIoayA9PiAhdGhpcy5leGNsdWRlS2V5cy5pbmNsdWRlcyhrKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhYmFzZVxuICAgIC5sb2FkU2NoZW1hKClcbiAgICAudGhlbihzY2hlbWFDb250cm9sbGVyID0+IHNjaGVtYUNvbnRyb2xsZXIuZ2V0T25lU2NoZW1hKHRoaXMuY2xhc3NOYW1lKSlcbiAgICAudGhlbihzY2hlbWEgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcyk7XG4gICAgICB0aGlzLmtleXMgPSBmaWVsZHMuZmlsdGVyKGsgPT4gIXRoaXMuZXhjbHVkZUtleXMuaW5jbHVkZXMoaykpO1xuICAgIH0pO1xufTtcblxuLy8gQXVnbWVudHMgdGhpcy5yZXNwb25zZSB3aXRoIGRhdGEgYXQgdGhlIHBhdGhzIHByb3ZpZGVkIGluIHRoaXMuaW5jbHVkZS5cbl9VbnNhZmVSZXN0UXVlcnkucHJvdG90eXBlLmhhbmRsZUluY2x1ZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluY2x1ZGUubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGF0aFJlc3BvbnNlID0gaW5jbHVkZVBhdGgoXG4gICAgdGhpcy5jb25maWcsXG4gICAgdGhpcy5hdXRoLFxuICAgIHRoaXMucmVzcG9uc2UsXG4gICAgdGhpcy5pbmNsdWRlWzBdLFxuICAgIHRoaXMucmVzdE9wdGlvbnNcbiAgKTtcbiAgaWYgKHBhdGhSZXNwb25zZS50aGVuKSB7XG4gICAgcmV0dXJuIHBhdGhSZXNwb25zZS50aGVuKG5ld1Jlc3BvbnNlID0+IHtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBuZXdSZXNwb25zZTtcbiAgICAgIHRoaXMuaW5jbHVkZSA9IHRoaXMuaW5jbHVkZS5zbGljZSgxKTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUluY2x1ZGUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmluY2x1ZGUubGVuZ3RoID4gMCkge1xuICAgIHRoaXMuaW5jbHVkZSA9IHRoaXMuaW5jbHVkZS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVJbmNsdWRlKCk7XG4gIH1cblxuICByZXR1cm4gcGF0aFJlc3BvbnNlO1xufTtcblxuLy9SZXR1cm5zIGEgcHJvbWlzZSBvZiBhIHByb2Nlc3NlZCBzZXQgb2YgcmVzdWx0c1xuX1Vuc2FmZVJlc3RRdWVyeS5wcm90b3R5cGUucnVuQWZ0ZXJGaW5kVHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnJlc3BvbnNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdGhpcy5ydW5BZnRlckZpbmQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gQXZvaWQgZG9pbmcgYW55IHNldHVwIGZvciB0cmlnZ2VycyBpZiB0aGVyZSBpcyBubyAnYWZ0ZXJGaW5kJyB0cmlnZ2VyIGZvciB0aGlzIGNsYXNzLlxuICBjb25zdCBoYXNBZnRlckZpbmRIb29rID0gdHJpZ2dlcnMudHJpZ2dlckV4aXN0cyhcbiAgICB0aGlzLmNsYXNzTmFtZSxcbiAgICB0cmlnZ2Vycy5UeXBlcy5hZnRlckZpbmQsXG4gICAgdGhpcy5jb25maWcuYXBwbGljYXRpb25JZFxuICApO1xuICBpZiAoIWhhc0FmdGVyRmluZEhvb2spIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgLy8gU2tpcCBBZ2dyZWdhdGUgYW5kIERpc3RpbmN0IFF1ZXJpZXNcbiAgaWYgKHRoaXMuZmluZE9wdGlvbnMucGlwZWxpbmUgfHwgdGhpcy5maW5kT3B0aW9ucy5kaXN0aW5jdCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIGNvbnN0IGpzb24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlc3RPcHRpb25zKTtcbiAganNvbi53aGVyZSA9IHRoaXMucmVzdFdoZXJlO1xuICBjb25zdCBwYXJzZVF1ZXJ5ID0gbmV3IFBhcnNlLlF1ZXJ5KHRoaXMuY2xhc3NOYW1lKTtcbiAgcGFyc2VRdWVyeS53aXRoSlNPTihqc29uKTtcbiAgLy8gUnVuIGFmdGVyRmluZCB0cmlnZ2VyIGFuZCBzZXQgdGhlIG5ldyByZXN1bHRzXG4gIHJldHVybiB0cmlnZ2Vyc1xuICAgIC5tYXliZVJ1bkFmdGVyRmluZFRyaWdnZXIoXG4gICAgICB0cmlnZ2Vycy5UeXBlcy5hZnRlckZpbmQsXG4gICAgICB0aGlzLmF1dGgsXG4gICAgICB0aGlzLmNsYXNzTmFtZSxcbiAgICAgIHRoaXMucmVzcG9uc2UucmVzdWx0cyxcbiAgICAgIHRoaXMuY29uZmlnLFxuICAgICAgcGFyc2VRdWVyeSxcbiAgICAgIHRoaXMuY29udGV4dFxuICAgIClcbiAgICAudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBwcm9wZXJseSBzZXQgdGhlIGNsYXNzTmFtZSBiYWNrXG4gICAgICBpZiAodGhpcy5yZWRpcmVjdENsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlLnJlc3VsdHMgPSByZXN1bHRzLm1hcChvYmplY3QgPT4ge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQYXJzZS5PYmplY3QpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0pTT04oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0LmNsYXNzTmFtZSA9IHRoaXMucmVkaXJlY3RDbGFzc05hbWU7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc3BvbnNlLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuLy8gQWRkcyBpbmNsdWRlZCB2YWx1ZXMgdG8gdGhlIHJlc3BvbnNlLlxuLy8gUGF0aCBpcyBhIGxpc3Qgb2YgZmllbGQgbmFtZXMuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXVnbWVudGVkIHJlc3BvbnNlLlxuZnVuY3Rpb24gaW5jbHVkZVBhdGgoY29uZmlnLCBhdXRoLCByZXNwb25zZSwgcGF0aCwgcmVzdE9wdGlvbnMgPSB7fSkge1xuICB2YXIgcG9pbnRlcnMgPSBmaW5kUG9pbnRlcnMocmVzcG9uc2UucmVzdWx0cywgcGF0aCk7XG4gIGlmIChwb2ludGVycy5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBjb25zdCBwb2ludGVyc0hhc2ggPSB7fTtcbiAgZm9yICh2YXIgcG9pbnRlciBvZiBwb2ludGVycykge1xuICAgIGlmICghcG9pbnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHBvaW50ZXIuY2xhc3NOYW1lO1xuICAgIC8vIG9ubHkgaW5jbHVkZSB0aGUgZ29vZCBwb2ludGVyc1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHBvaW50ZXJzSGFzaFtjbGFzc05hbWVdID0gcG9pbnRlcnNIYXNoW2NsYXNzTmFtZV0gfHwgbmV3IFNldCgpO1xuICAgICAgcG9pbnRlcnNIYXNoW2NsYXNzTmFtZV0uYWRkKHBvaW50ZXIub2JqZWN0SWQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBpbmNsdWRlUmVzdE9wdGlvbnMgPSB7fTtcbiAgaWYgKHJlc3RPcHRpb25zLmtleXMpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChyZXN0T3B0aW9ucy5rZXlzLnNwbGl0KCcsJykpO1xuICAgIGNvbnN0IGtleVNldCA9IEFycmF5LmZyb20oa2V5cykucmVkdWNlKChzZXQsIGtleSkgPT4ge1xuICAgICAgY29uc3Qga2V5UGF0aCA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChpOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSAhPSBrZXlQYXRoW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPCBrZXlQYXRoLmxlbmd0aCkge1xuICAgICAgICBzZXQuYWRkKGtleVBhdGhbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9LCBuZXcgU2V0KCkpO1xuICAgIGlmIChrZXlTZXQuc2l6ZSA+IDApIHtcbiAgICAgIGluY2x1ZGVSZXN0T3B0aW9ucy5rZXlzID0gQXJyYXkuZnJvbShrZXlTZXQpLmpvaW4oJywnKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdE9wdGlvbnMuZXhjbHVkZUtleXMpIHtcbiAgICBjb25zdCBleGNsdWRlS2V5cyA9IG5ldyBTZXQocmVzdE9wdGlvbnMuZXhjbHVkZUtleXMuc3BsaXQoJywnKSk7XG4gICAgY29uc3QgZXhjbHVkZUtleVNldCA9IEFycmF5LmZyb20oZXhjbHVkZUtleXMpLnJlZHVjZSgoc2V0LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGtleVBhdGggPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoaTsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGhbaV0gIT0ga2V5UGF0aFtpXSkge1xuICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09IGtleVBhdGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBzZXQuYWRkKGtleVBhdGhbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9LCBuZXcgU2V0KCkpO1xuICAgIGlmIChleGNsdWRlS2V5U2V0LnNpemUgPiAwKSB7XG4gICAgICBpbmNsdWRlUmVzdE9wdGlvbnMuZXhjbHVkZUtleXMgPSBBcnJheS5mcm9tKGV4Y2x1ZGVLZXlTZXQpLmpvaW4oJywnKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdE9wdGlvbnMuaW5jbHVkZVJlYWRQcmVmZXJlbmNlKSB7XG4gICAgaW5jbHVkZVJlc3RPcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gcmVzdE9wdGlvbnMuaW5jbHVkZVJlYWRQcmVmZXJlbmNlO1xuICAgIGluY2x1ZGVSZXN0T3B0aW9ucy5pbmNsdWRlUmVhZFByZWZlcmVuY2UgPSByZXN0T3B0aW9ucy5pbmNsdWRlUmVhZFByZWZlcmVuY2U7XG4gIH0gZWxzZSBpZiAocmVzdE9wdGlvbnMucmVhZFByZWZlcmVuY2UpIHtcbiAgICBpbmNsdWRlUmVzdE9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSByZXN0T3B0aW9ucy5yZWFkUHJlZmVyZW5jZTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5UHJvbWlzZXMgPSBPYmplY3Qua2V5cyhwb2ludGVyc0hhc2gpLm1hcChhc3luYyBjbGFzc05hbWUgPT4ge1xuICAgIGNvbnN0IG9iamVjdElkcyA9IEFycmF5LmZyb20ocG9pbnRlcnNIYXNoW2NsYXNzTmFtZV0pO1xuICAgIGxldCB3aGVyZTtcbiAgICBpZiAob2JqZWN0SWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hlcmUgPSB7IG9iamVjdElkOiBvYmplY3RJZHNbMF0gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmUgPSB7IG9iamVjdElkOiB7ICRpbjogb2JqZWN0SWRzIH0gfTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBSZXN0UXVlcnkoe1xuICAgICAgbWV0aG9kOiBvYmplY3RJZHMubGVuZ3RoID09PSAxID8gUmVzdFF1ZXJ5Lk1ldGhvZC5nZXQgOiBSZXN0UXVlcnkuTWV0aG9kLmZpbmQsXG4gICAgICBjb25maWcsXG4gICAgICBhdXRoLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcmVzdFdoZXJlOiB3aGVyZSxcbiAgICAgIHJlc3RPcHRpb25zOiBpbmNsdWRlUmVzdE9wdGlvbnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4ZWN1dGUoeyBvcDogJ2dldCcgfSkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHJlc3VsdHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gR2V0IHRoZSBvYmplY3RzIGZvciBhbGwgdGhlc2Ugb2JqZWN0IGlkc1xuICByZXR1cm4gUHJvbWlzZS5hbGwocXVlcnlQcm9taXNlcykudGhlbihyZXNwb25zZXMgPT4ge1xuICAgIHZhciByZXBsYWNlID0gcmVzcG9uc2VzLnJlZHVjZSgocmVwbGFjZSwgaW5jbHVkZVJlc3BvbnNlKSA9PiB7XG4gICAgICBmb3IgKHZhciBvYmogb2YgaW5jbHVkZVJlc3BvbnNlLnJlc3VsdHMpIHtcbiAgICAgICAgb2JqLl9fdHlwZSA9ICdPYmplY3QnO1xuICAgICAgICBvYmouY2xhc3NOYW1lID0gaW5jbHVkZVJlc3BvbnNlLmNsYXNzTmFtZTtcblxuICAgICAgICBpZiAob2JqLmNsYXNzTmFtZSA9PSAnX1VzZXInICYmICFhdXRoLmlzTWFzdGVyKSB7XG4gICAgICAgICAgZGVsZXRlIG9iai5zZXNzaW9uVG9rZW47XG4gICAgICAgICAgZGVsZXRlIG9iai5hdXRoRGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlW29iai5vYmplY3RJZF0gPSBvYmo7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZTtcbiAgICB9LCB7fSk7XG5cbiAgICB2YXIgcmVzcCA9IHtcbiAgICAgIHJlc3VsdHM6IHJlcGxhY2VQb2ludGVycyhyZXNwb25zZS5yZXN1bHRzLCBwYXRoLCByZXBsYWNlKSxcbiAgICB9O1xuICAgIGlmIChyZXNwb25zZS5jb3VudCkge1xuICAgICAgcmVzcC5jb3VudCA9IHJlc3BvbnNlLmNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gcmVzcDtcbiAgfSk7XG59XG5cbi8vIE9iamVjdCBtYXkgYmUgYSBsaXN0IG9mIFJFU1QtZm9ybWF0IG9iamVjdCB0byBmaW5kIHBvaW50ZXJzIGluLCBvclxuLy8gaXQgbWF5IGJlIGEgc2luZ2xlIG9iamVjdC5cbi8vIElmIHRoZSBwYXRoIHlpZWxkcyB0aGluZ3MgdGhhdCBhcmVuJ3QgcG9pbnRlcnMsIHRoaXMgdGhyb3dzIGFuIGVycm9yLlxuLy8gUGF0aCBpcyBhIGxpc3Qgb2YgZmllbGRzIHRvIHNlYXJjaCBpbnRvLlxuLy8gUmV0dXJucyBhIGxpc3Qgb2YgcG9pbnRlcnMgaW4gUkVTVCBmb3JtYXQuXG5mdW5jdGlvbiBmaW5kUG9pbnRlcnMob2JqZWN0LCBwYXRoKSB7XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhbnN3ZXIgPSBbXTtcbiAgICBmb3IgKHZhciB4IG9mIG9iamVjdCkge1xuICAgICAgYW5zd2VyID0gYW5zd2VyLmNvbmNhdChmaW5kUG9pbnRlcnMoeCwgcGF0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gYW5zd2VyO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8ICFvYmplY3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAocGF0aC5sZW5ndGggPT0gMCkge1xuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0Ll9fdHlwZSA9PSAnUG9pbnRlcicpIHtcbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHN1Ym9iamVjdCA9IG9iamVjdFtwYXRoWzBdXTtcbiAgaWYgKCFzdWJvYmplY3QpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGZpbmRQb2ludGVycyhzdWJvYmplY3QsIHBhdGguc2xpY2UoMSkpO1xufVxuXG4vLyBPYmplY3QgbWF5IGJlIGEgbGlzdCBvZiBSRVNULWZvcm1hdCBvYmplY3RzIHRvIHJlcGxhY2UgcG9pbnRlcnNcbi8vIGluLCBvciBpdCBtYXkgYmUgYSBzaW5nbGUgb2JqZWN0LlxuLy8gUGF0aCBpcyBhIGxpc3Qgb2YgZmllbGRzIHRvIHNlYXJjaCBpbnRvLlxuLy8gcmVwbGFjZSBpcyBhIG1hcCBmcm9tIG9iamVjdCBpZCAtPiBvYmplY3QuXG4vLyBSZXR1cm5zIHNvbWV0aGluZyBhbmFsb2dvdXMgdG8gb2JqZWN0LCBidXQgd2l0aCB0aGUgYXBwcm9wcmlhdGVcbi8vIHBvaW50ZXJzIGluZmxhdGVkLlxuZnVuY3Rpb24gcmVwbGFjZVBvaW50ZXJzKG9iamVjdCwgcGF0aCwgcmVwbGFjZSkge1xuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gb2JqZWN0XG4gICAgICAubWFwKG9iaiA9PiByZXBsYWNlUG9pbnRlcnMob2JqLCBwYXRoLCByZXBsYWNlKSlcbiAgICAgIC5maWx0ZXIob2JqID0+IHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCAhb2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvYmplY3QgJiYgb2JqZWN0Ll9fdHlwZSA9PT0gJ1BvaW50ZXInKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVtvYmplY3Qub2JqZWN0SWRdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHN1Ym9iamVjdCA9IG9iamVjdFtwYXRoWzBdXTtcbiAgaWYgKCFzdWJvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHZhciBuZXdzdWIgPSByZXBsYWNlUG9pbnRlcnMoc3Vib2JqZWN0LCBwYXRoLnNsaWNlKDEpLCByZXBsYWNlKTtcbiAgdmFyIGFuc3dlciA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGtleSA9PSBwYXRoWzBdKSB7XG4gICAgICBhbnN3ZXJba2V5XSA9IG5ld3N1YjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5zd2VyW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFuc3dlcjtcbn1cblxuLy8gRmluZHMgYSBzdWJvYmplY3QgdGhhdCBoYXMgdGhlIGdpdmVuIGtleSwgaWYgdGhlcmUgaXMgb25lLlxuLy8gUmV0dXJucyB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuZnVuY3Rpb24gZmluZE9iamVjdFdpdGhLZXkocm9vdCwga2V5KSB7XG4gIGlmICh0eXBlb2Ygcm9vdCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJvb3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAodmFyIGl0ZW0gb2Ygcm9vdCkge1xuICAgICAgY29uc3QgYW5zd2VyID0gZmluZE9iamVjdFdpdGhLZXkoaXRlbSwga2V5KTtcbiAgICAgIGlmIChhbnN3ZXIpIHtcbiAgICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJvb3QgJiYgcm9vdFtrZXldKSB7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cbiAgZm9yICh2YXIgc3Via2V5IGluIHJvb3QpIHtcbiAgICBjb25zdCBhbnN3ZXIgPSBmaW5kT2JqZWN0V2l0aEtleShyb290W3N1YmtleV0sIGtleSk7XG4gICAgaWYgKGFuc3dlcikge1xuICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXN0UXVlcnk7XG4vLyBGb3IgdGVzdHNcbm1vZHVsZS5leHBvcnRzLl9VbnNhZmVSZXN0UXVlcnkgPSBfVW5zYWZlUmVzdFF1ZXJ5O1xuIl19